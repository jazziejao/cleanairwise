<!doctype html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AIRWISE Dashboard</title>

  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            primary: {
              50: '#f0fdf4',
              100: '#dcfce7',
              200: '#bbf7d0',
              300: '#86efac',
              400: '#4ade80',
              500: '#22c55e',
              600: '#16a34a',
              700: '#15803d',
              800: '#166534',
              900: '#14532d',
            },
            accent: {
              DEFAULT: '#06b6d4',
              light: '#22d3ee',
              dark: '#0891b2',
            },
            surface: {
              light: '#ffffff',
              dark: '#0f172a',
            }
          }
        }
      }
    };
  </script>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com/3.4.17"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- For coloring  -->
  <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>

  <!-- Charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
  
  
  <!-- GeoTIFF raster support -->
  <script src="https://unpkg.com/georaster/dist/georaster.browser.min.js"></script>
  <script src="https://unpkg.com/georaster-layer-for-leaflet/dist/georaster-layer-for-leaflet.min.js"></script>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <!-- Optional SDKs (keep if you need them) -->
  <script src="/_sdk/element_sdk.js"></script>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>

  <style>
    * { font-family: 'Space Grotesk', sans-serif; }
    .mono { font-family: 'JetBrains Mono', monospace; }

    /* Update the existing color-bar-height to 10 colors - GREY SCHEME */
    .color-bar-height { 
      background: linear-gradient(to right, 
        #f7f7f7, #e0e0e0, #cccccc, #bdbdbd, #a6a6a6,
        #8c8c8c, #737373, #595959, #404040, #1a1a1a
      ); 
    }
    /* Custom scrollbar */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

    /* Leaflet control styling uses CSS vars set by dark toggle */
    .leaflet-control-zoom a {
      background: var(--control-bg) !important;
      color: var(--control-text) !important;
      border: 1px solid var(--control-border) !important;
    }

    /* Toggle switch */
    .toggle-track { transition: background-color 0.2s ease; }
    .toggle-thumb { transition: transform 0.2s ease; }

    /* Gradient animations */
    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    .gradient-animate {
      background-size: 200% 200%;
      animation: gradient-shift 8s ease infinite;
    }

    /* Loading pulse */
    @keyframes pulse-ring {
      0% { transform: scale(0.8); opacity: 1; }
      100% { transform: scale(1.4); opacity: 0; }
    }
    .pulse-ring { animation: pulse-ring 1.5s ease-out infinite; }

    /* Color bar gradients */
    .color-bar-pm25 { background: linear-gradient(to right, #00e400, #ffff00, #ff7e00, #ff0000, #8f3f97, #7e0023); }
    .color-bar-pm10 { background: linear-gradient(to right, #00e400, #ffff00, #ff7e00, #ff0000, #8f3f97, #7e0023); }
    .color-bar-lst { background: linear-gradient(to right, #313695, #4575b4, #74add1, #abd9e9, #fee090, #fdae61, #f46d43, #d73027, #a50026); }
    
    
    /* 10-class Reds (light -> dark) */
    .color-bar-canyon {
      background: linear-gradient(to right,
        #fff5f0, #fee0d2, #fcbba1, #fc9272, #fb6a4a,
        #ef3b2c, #cb181d, #a50f15, #67000d, #3b0007
      );
    }

    /* 10-class Blues (light -> dark) */
    .color-bar-lst {
      background: linear-gradient(to right,
        #f7fbff, #e3eef8, #cfe1f2, #aecdE6, #83b8da,
        #5aa2cf, #3589c0, #1b6fb2, #08519c, #08306b
      );
    }

    /* Mobile panel helper */
    .panel-slide { transition: transform 220ms ease; }

    @media (max-width: 768px) {
      .mobile-hidden { transform: translateX(-110%); }
    }

    @media (max-width: 768px) {
      /* Stage */
      #urban-explorer {
        position: absolute;
        inset: 0;
        display: block; /* mobile overlay style */
      }

      /* Map fills screen */
      #urban-map-wrap {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
      }

      /* Sidebar overlays map */
      #left-panel {
        position: fixed;
        top: 0;
        left: 0;
        height: 100dvh;
        width: 20rem;   /* w-80 */
        z-index: 1500;  /* above Leaflet */
      }

      #left-panel.mobile-hidden {
        transform: translateX(-110%);
        pointer-events: none;
        opacity: 0;
      }
    }


    @media (max-width: 768px) {
      #sensor-left-panel{
        position: fixed;
        top: 0;
        left: 0;
        height: 100dvh;
        width: 20rem;     /* w-80 */
        z-index: 1500;    /* above Leaflet */
      }

      #sensor-left-panel.mobile-hidden-sensor{
        transform: translateX(-110%);
        pointer-events: none;
        opacity: 0;
      }
    }

    
    /* Ensure Leaflet map containers can render */
    #urban-map, #sensor-map { width: 100%; height: 100%; }


  </style>

</head>

<body class="h-full bg-gray-50 dark:bg-slate-900 text-gray-900 dark:text-gray-100 overflow-hidden m-0 p-0">

  <div id="app" class="h-full w-full flex flex-col">

    <!-- Header -->
    <header id="main-header" class="hidden flex-shrink-0 bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 px-4 py-3 z-50 sticky top-0">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-3">

        <!-- AIRWISE Logo Placeholder -->
        <div class="w-15 h-15 rounded-xl border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 flex items-center justify-center shadow-sm">
          <span class="mono text-xs font-semibold tracking-wider text-gray-400 dark:text-gray-500">
            <img src="./assets/airwise_logo.png" alt="AIRWISE Logo" class="w-12 h-12 object-contain">
          </span>
        </div>

          <div>
            <h1 id="dashboard-title" class="text-lg font-semibold tracking-tight">AIRWISE</h1>
            <p id="dashboard-subtitle" class="text-xs text-gray-500 dark:text-gray-400">Air Quality and Urban Morphology</p>
          </div>
        </div>


        <!-- Navigation Tabs -->
        <nav class="flex items-center gap-1 bg-gray-100 dark:bg-slate-700 rounded-lg p-1">

          <button id="tab-urban" onclick="switchTab('urban')"
            class="tab-btn px-2 md:px-4 py-1.5 md:py-2 rounded-md text-xs md:text-sm font-medium transition-all">
            <span class="flex items-center gap-1 md:gap-2">
              <svg class="w-4 h-4 md:w-4 md:h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
              </svg>
              <span class="hidden sm:inline">Urban Form</span>
            </span>
          </button>

          <button id="tab-sensors" onclick="switchTab('sensors')"
            class="tab-btn px-2 md:px-4 py-1.5 md:py-2 rounded-md text-xs md:text-sm font-medium transition-all">
            <span class="flex items-center gap-1 md:gap-2">
              <svg class="w-4 h-4 md:w-4 md:h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z" />
              </svg>
              <span class="hidden sm:inline">Ground Sensors</span>
            </span>
          </button>

        </nav>

        <!-- Controls -->
        <div class="flex items-center gap-3">
          <!-- Home / Landing -->
          <button onclick="showLanding()" class="hidden sm:inline-flex items-center gap-2 px-3 py-2 rounded-lg bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 transition-colors text-sm">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9.5l9-7 9 7V20a1 1 0 01-1 1h-5v-6H9v6H4a1 1 0 01-1-1V9.5z"/>
            </svg>
            Home
          </button>

          <button onclick="toggleDarkMode()" class="p-2 rounded-lg bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 transition-colors">
            <svg id="sun-icon" class="w-5 h-5 text-amber-500 hidden dark:block" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
            </svg>
            <svg id="moon-icon" class="w-5 h-5 text-slate-600 block dark:hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
            </svg>
          </button>
        </div>

      </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex overflow-hidden relative">

      <!-- Landing Page Overlay -->
      <section id="landing" class="absolute inset-0 z-[2000] bg-white dark:bg-slate-900">
        <!-- Background -->
        <div class="absolute inset-0 bg-white dark:bg-slate-900"></div>

        <!-- Content -->
        <div class="relative h-full w-full overflow-auto">
          <div class="max-w-6xl mx-auto px-6 py-10 md:py-14">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-3">
                <div class="flex items-center gap-4">

                  <!-- AIRWISE Landing Logo -->
                  <div class="w-14 h-14 rounded-2xl border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 flex items-center justify-center shadow-sm">
                    <span class="mono text-sm font-semibold tracking-wider text-gray-400 dark:text-gray-500">
                      <img src="./assets/airwise_logo.png" alt="AIRWISE Logo" class="w-20 h-20 object-contain">
                    </span>
                  </div>

                  <div>
                    <div class="text-sm text-gray-500 dark:text-gray-400">AIRWISE</div>
                    <div class="text-xl font-semibold tracking-tight">Dashboard</div>
                  </div>
                </div>
              </div>

            </div>

            <div class="mt-10 grid lg:grid-cols-2 gap-8 items-start">
              <!-- Hero -->
              <div class="space-y-5">
                <h2 class="text-5xl md:text-5xl font-semibold tracking-tight leading-tight">
                  Air quality and <span class="text-emerald-600 dark:text-emerald-400">urban morphology</span>.
                </h2>

                <p class="text-base md:text-lg text-gray-600 dark:text-gray-300 max-w-xl">
                  Explore how building form, street structure, and environmental overlays relate to pollution.
                </p>

                <div class="flex flex-wrap items-center gap-2 pt-3">

                  <button onclick="showAbout()" class="inline-flex items-center gap-2 px-3 py-2 rounded-lg bg-gray-100 dark:bg-slate-800 hover:bg-gray-200 dark:hover:bg-slate-700 transition-colors text-sm">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M12 20a8 8 0 100-16 8 8 0 000 16z"/>
                    </svg>
                    About
                  </button>  

                  <button 
                    onclick="enterApp('urban')" 
                    class="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-emerald-500 hover:bg-emerald-600 text-white text-sm font-medium transition-colors shadow-sm">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M3 21h18M5 21V7a2 2 0 012-2h10a2 2 0 012 2v14"/>
                    </svg>
                    Urban Explorer
                  </button>

                  <button 
                    onclick="enterApp('sensors')" 
                    class="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-cyan-500 hover:bg-cyan-600 text-white text-sm font-medium transition-colors shadow-sm">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M9 3v2m6-2v2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2z"/>
                    </svg>
                    Ground Sensors
                  </button>

                </div>

                
                <!-- Partners -->
                <div class="pt-6">
                  <div class="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 mb-3">
                    Partners
                  </div>

                  <div class="flex flex-wrap gap-3">

                    <!-- Urban Form Lab -->
                    <div class="px-3 py-2 rounded-xl bg-white/80 dark:bg-slate-800/70 
                                border border-gray-200/70 dark:border-slate-700 
                                flex items-center gap-3">
                      <img src="./assets/unibath.svg"
                          alt="Urban Form Lab Logo"
                          class="w-25 h-20 object-contain">
                      <div class="text-sm text-gray-700 dark:text-gray-200">
                       
                      </div>
                    </div>

                    <!-- AirGradient -->
                    <div class="px-3 py-2 rounded-xl bg-white/80 dark:bg-slate-800/70 
                                border border-gray-200/70 dark:border-slate-700 
                                flex items-center gap-3">
                      <img src="./assets/dlsu-logo.png"
                          alt="AirGradient Logo"
                          class="w-20 h-15 object-contain">
                      <div class="text-sm text-gray-700 dark:text-gray-200">
                        
                      </div>
                    </div>

                  </div>
                </div>

              </div>

              <div class="grid sm:grid-cols-2 gap-4">
                <div class="rounded-2xl bg-white/80 dark:bg-slate-800/70 border border-gray-200/70 dark:border-slate-700 p-5 shadow-xl shadow-black/10 dark:shadow-black/40 hover:shadow-2xl transition-shadow">
                  <div class="flex items-center gap-2 mb-2">
                    <div class="w-9 h-9 rounded-xl bg-emerald-500/10 text-emerald-600 dark:text-emerald-400 flex items-center justify-center">
                      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 21h18M5 21V7a2 2 0 012-2h10a2 2 0 012 2v14" />
                      </svg>
                    </div>
                    <div class="font-semibold">Urban Form Explorer</div>
                  </div>
                  <p class="text-sm text-gray-600 dark:text-gray-300">
                    Toggle building heights, street network attributes, and environmental overlays.
                  </p>
                </div>



                <div class="rounded-2xl bg-white/80 dark:bg-slate-800/70 border border-gray-200/70 dark:border-slate-700 p-5 shadow-xl shadow-black/10 dark:shadow-black/40 hover:shadow-2xl transition-shadow">
                  <div class="flex items-center gap-2 mb-2">
                    <div class="w-9 h-9 rounded-xl bg-cyan-500/10 text-cyan-600 dark:text-cyan-400 flex items-center justify-center">
                      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 3v2m6-2v2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2z" />
                      </svg>
                    </div>
                    <div class="font-semibold">Ground Sensors</div>
                  </div>
                  <p class="text-sm text-gray-600 dark:text-gray-300">
                    Explore sensor readings and inspect station details on the map.
                  </p>
                </div>


              </div>           
            </div>

            <div class="mt-10 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-10 text-xs text-gray-500 dark:text-gray-400">
              <div>
                © AIRWISE • This work is supported by a Research Collaborations grant, ID 1203727468, under the International Science Partnerships Fund. The grant is funded by the UK Department for Science Innovation and Technology in partnership with the British Council. For further information, please visit 
                <a href="https://www.gov.uk/government/publications/international-science-partnerships-fund-ispf"
                   target="_blank"
                   rel="noopener noreferrer"
                   class="underline hover:text-emerald-600 dark:hover:text-emerald-400 break-all">
                   https://www.gov.uk/government/publications/international-science-partnerships-fund-ispf
                </a>.
              </div>

              <span class="font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400">
                Supported by British Council
              </span>

              <!-- Logo placeholder (replace later) -->
              <div class="h-30 w-70 rounded-lg border border-gray-200 dark:border-slate-700 bg-white/80 dark:bg-slate-800/70 flex items-center justify-center">
                <span class="mono text-[10px] text-gray-400 dark:text-gray-500">
                  <img src="./assets/british_council.png" 
                      alt="British Council Logo" 
                      class="w-70 h-30 object-contain">
                </span>
              </div>
            </div>

          </div>
        </div>
      </section>


    <!-- About Overlay -->
    <section id="about" class="absolute inset-0 z-[2100] bg-white dark:bg-slate-900 hidden">
      <div class="relative h-full w-full overflow-auto">
        <div class="max-w-4xl mx-auto px-6 py-10 md:py-14">
          <div class="flex items-start justify-between gap-4">
            <div>
              <div class="text-sm text-gray-500 dark:text-gray-400"><img src="./assets/airwise_logo.png" alt="AIRWISE Logo" class="w-12 h-12 object-contain mb-4"></div>
              <h2 class="text-3xl md:text-4xl font-semibold tracking-tight mt-1">About</h2>
              <p class="mt-3 text-gray-600 dark:text-gray-300 max-w-2xl">
                AIRWISE connects urban morphology (building form, street structure) and environmental layers to observed air pollution patterns to support evidence-based urban interventions.
              </p>
            </div>
          </div>

          <div class="rounded-2xl bg-white/80 dark:bg-slate-800/70 border border-gray-200/70 dark:border-slate-700 p-5 shadow-sm mt-5">
            <div class="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 mb-2">
              What you can do
            </div>

            <ul class="text-sm text-gray-600 dark:text-gray-300 space-y-2 list-disc pl-5">
              <li>Explore building height patterns and street characteristics.</li>
              <li>Overlay environmental surfaces like temperature and particulate heatmaps.</li>
              <li>Compare against nearby ground sensor measurements.</li>
            </ul>

          </div>

          <div class="mt-10">
            <button onclick="backToHomeFromAbout()"
              class="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-emerald-500 hover:bg-emerald-600 text-white text-sm font-medium transition-colors shadow-sm">
              ← Back to Home
            </button>
          </div>
        </div>
      </div>
    </section>


      <!-- Urban Form Explorer -->
      <div id="urban-explorer" class="absolute inset-0 flex">
        <!-- Left Panel - Controls -->
        <aside id="left-panel"
          class="w-80 flex-shrink-0 bg-white dark:bg-slate-800 border-r border-gray-200 dark:border-slate-700 flex flex-col overflow-hidden panel-slide z-[1500]">
            <div class="flex-1 overflow-y-auto p-4 space-y-4">



            <!-- City Selection -->
            <div class="space-y-2">
              <h3 class="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
                Study Areas
              </h3>

              <!-- View Mode Toggle -->
              <div class="flex items-center gap-2 p-2 bg-gray-50 dark:bg-slate-700/50 rounded-lg">
                <button onclick="(async()=>{ await setViewMode('all', true); })()" id="view-all-btn"
                  class="flex-1 px-3 py-1.5 rounded-md text-xs font-medium bg-emerald-500 text-white transition-all">
                  All Cities
                </button>

                <button onclick="(async()=>{ await setViewMode('single'); })()" id="view-single-btn"
                  class="flex-1 px-3 py-1.5 rounded-md text-xs font-medium text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-slate-600 transition-all">
                  Single City
                </button>
              </div>

              <!-- City Buttons -->
              <div id="city-buttons" class="grid grid-cols-2 gap-2">
                <button onclick="selectCity('lawton')" data-city="lawton"
                  class="city-btn p-3 rounded-lg border-2 border-transparent bg-gray-50 dark:bg-slate-700 hover:border-emerald-500 transition-all text-left">
                  <div class="flex items-center gap-2 mb-1">
                    <div class="w-3 h-3 rounded-full bg-rose-500"></div>
                    <span class="text-sm font-medium">Lawton</span>
                  </div>
                  <span class="text-xs text-gray-500 dark:text-gray-400">Manila</span>
                </button>

                <button onclick="selectCity('pasay')" data-city="pasay"
                  class="city-btn p-3 rounded-lg border-2 border-transparent bg-gray-50 dark:bg-slate-700 hover:border-emerald-500 transition-all text-left">
                  <div class="flex items-center gap-2 mb-1">
                    <div class="w-3 h-3 rounded-full bg-amber-500"></div>
                    <span class="text-sm font-medium">Pasay</span>
                  </div>
                  <span class="text-xs text-gray-500 dark:text-gray-400">Pasay City</span>
                </button>

                <button onclick="selectCity('gateway')" data-city="gateway"
                  class="city-btn p-3 rounded-lg border-2 border-transparent bg-gray-50 dark:bg-slate-700 hover:border-emerald-500 transition-all text-left">
                  <div class="flex items-center gap-2 mb-1">
                    <div class="w-3 h-3 rounded-full bg-cyan-500"></div>
                    <span class="text-sm font-medium">Gateway</span>
                  </div>
                  <span class="text-xs text-gray-500 dark:text-gray-400">Gateway</span>
                </button>

                <button onclick="selectCity('ayala')" data-city="ayala"
                  class="city-btn p-3 rounded-lg border-2 border-transparent bg-gray-50 dark:bg-slate-700 hover:border-emerald-500 transition-all text-left">
                  <div class="flex items-center gap-2 mb-1">
                    <div class="w-3 h-3 rounded-full bg-violet-500"></div>
                    <span class="text-sm font-medium">Ayala</span>
                  </div>
                  <span class="text-xs text-gray-500 dark:text-gray-400">Ayala</span>
                </button>
              </div>
            </div>

            <!-- Divider -->
            <div class="h-px bg-gray-200 dark:bg-slate-700"></div>

            <!-- Urban Layers -->
            <div class="space-y-2">
              <h3 class="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                </svg>
                Urban Form Layers
              </h3>

              <!-- Building Footprints -->
              <div class="p-3 rounded-lg bg-gray-50 dark:bg-slate-700/50 space-y-2">
                <label class="flex items-center justify-between cursor-pointer">
                  <span class="flex items-center gap-2 text-sm">
                    <svg class="w-4 h-4 text-emerald-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
                    </svg>
                    Building Heights
                  </span>
                  <div class="relative">
                    <input type="checkbox" id="layer-buildings" onchange="toggleLayer('buildings')" class="sr-only peer">
                    <div class="w-9 h-5 bg-gray-300 dark:bg-slate-600 rounded-full peer-checked:bg-emerald-500 transition-colors toggle-track"></div>
                    <div class="absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full shadow peer-checked:translate-x-4 transition-transform toggle-thumb"></div>
                  </div>
                </label>
                <div id="building-legend" class="hidden space-y-1">
                  <div class="flex items-center justify-between mb-1">
                    <span class="text-xs text-gray-500 dark:text-gray-400">Height (m)</span>
                    <span id="legend-mode-indicator" class="text-xs font-mono text-gray-400 dark:text-gray-500"></span>
                  </div>
                  <div class="color-bar-height h-2 rounded-full"></div>
                  <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400 mono">
                    <span>0m</span><span>50m</span><span>100m+</span>
                  </div>
                </div>
              </div>

              <!-- Street Network -->
              <div class="p-3 rounded-lg bg-gray-50 dark:bg-slate-700/50 space-y-2">
                <label class="flex items-center justify-between cursor-pointer">
                  <span class="flex items-center gap-2 text-sm">
                    <svg class="w-4 h-4 text-cyan-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                    </svg>
                    Street Network
                  </span>
                  <div class="relative">
                    <input type="checkbox" id="layer-streets" onchange="toggleLayer('streets')" class="sr-only peer">
                    <div class="w-9 h-5 bg-gray-300 dark:bg-slate-600 rounded-full peer-checked:bg-cyan-500 transition-colors toggle-track"></div>
                    <div class="absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full shadow peer-checked:translate-x-4 transition-transform toggle-thumb"></div>
                  </div>
                </label>

                <div id="street-options" class="hidden pl-4 space-y-2 border-l-2 border-cyan-500/30">
                  <label class="flex items-center gap-2 text-xs cursor-pointer">
                    <input type="checkbox" id="street-canyon" onchange="toggleStreetOption('canyon')"
                      class="w-3.5 h-3.5 rounded border-gray-300 text-cyan-500 focus:ring-cyan-500">
                    <span>Street Canyon Values</span>
                  </label>

                  <div id="canyon-legend" class="hidden space-y-1">
                    <div class="color-bar-canyon h-1.5 rounded-full"></div>
                    <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400 mono">
                      <span>0.5</span><span>1.0</span><span>2.0+</span>
                    </div>
                  </div>

                  <label class="flex items-center gap-2 text-xs cursor-pointer">
                    <input type="checkbox" id="street-highway" onchange="toggleStreetOption('highway')"
                      class="w-3.5 h-3.5 rounded border-gray-300 text-cyan-500 focus:ring-cyan-500">
                    <span>Highway Categories</span>
                  </label>

                  <div id="highway-legend" class="hidden space-y-1 text-xs">
                    <div class="flex items-center gap-2"><span class="w-4 h-1 bg-red-500 rounded"></span>Primary</div>
                    <div class="flex items-center gap-2"><span class="w-4 h-1 bg-orange-500 rounded"></span>Secondary</div>
                    <div class="flex items-center gap-2"><span class="w-4 h-1 bg-yellow-500 rounded"></span>Tertiary</div>
                    <div class="flex items-center gap-2"><span class="w-4 h-1 bg-gray-400 rounded"></span>Residential</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Divider -->
            <div class="h-px bg-gray-200 dark:bg-slate-700"></div>

            <!-- Environmental Overlays -->
            <div class="space-y-2">
              <h3 class="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                </svg>
                Environmental Overlays
              </h3>

              <!-- LST -->
              <div class="p-3 rounded-lg bg-gray-50 dark:bg-slate-700/50 space-y-2">
                <label class="flex items-center justify-between cursor-pointer">
                  <span class="flex items-center gap-2 text-sm">
                    <svg class="w-4 h-4 text-orange-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                    </svg>
                    Land Surface Temp
                  </span>
                  <div class="relative">
                    <input type="checkbox" id="layer-lst" onchange="toggleLayer('lst')" class="sr-only peer">
                    <div class="w-9 h-5 bg-gray-300 dark:bg-slate-600 rounded-full peer-checked:bg-orange-500 transition-colors toggle-track"></div>
                    <div class="absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full shadow peer-checked:translate-x-4 transition-transform toggle-thumb"></div>
                  </div>
                </label>
                <div id="lst-legend" class="hidden space-y-1">
                  <div class="flex items-center justify-between">
                    <span class="text-xs text-gray-500 dark:text-gray-400">1-Year Average</span>
                    <span id="lst-mode-indicator" class="text-xs font-mono text-gray-400 dark:text-gray-500"></span>
                  </div>

                  <div id="lst-colorbar" class="h-2 rounded-full"></div>

                  <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400 mono">
                    <span>--</span><span>--</span><span>--</span>
                  </div>
                </div>
              </div>

              <!-- PM2.5 -->
              <div class="p-3 rounded-lg bg-gray-50 dark:bg-slate-700/50 space-y-2">
                <label class="flex items-center justify-between cursor-pointer">
                  <span class="flex items-center gap-2 text-sm">
                    <svg class="w-4 h-4 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" />
                    </svg>
                    PM2.5 Heatmap
                  </span>
                  <div class="relative">
                    <input type="checkbox" id="layer-pm25" onchange="toggleLayer('pm25')" class="sr-only peer">
                    <div class="w-9 h-5 bg-gray-300 dark:bg-slate-600 rounded-full peer-checked:bg-purple-500 transition-colors toggle-track"></div>
                    <div class="absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full shadow peer-checked:translate-x-4 transition-transform toggle-thumb"></div>
                  </div>
                </label>
                <div id="pm25-options" class="hidden space-y-2">
                  <div class="flex gap-1">
                    <button onclick="setPMDate(this, 'pm25', 'oct3')" class="pm25-date-btn flex-1 px-2 py-1 text-xs rounded bg-purple-500 text-white">Oct 3</button>
                    <button onclick="setPMDate(this, 'pm25', 'oct4')" class="pm25-date-btn flex-1 px-2 py-1 text-xs rounded bg-gray-200 dark:bg-slate-600">Oct 4</button>
                  </div>
                  <div class="grid grid-cols-4 gap-1">
                    <button onclick="setPMTime(this, 'pm25', '08:00')" class="pm25-time-btn px-2 py-1 text-xs rounded bg-purple-500 text-white">8:00</button>
                    <button onclick="setPMTime(this, 'pm25', '12:00')" class="pm25-time-btn px-2 py-1 text-xs rounded bg-gray-200 dark:bg-slate-600">12:00</button>
                    <button onclick="setPMTime(this, 'pm25', '17:00')" class="pm25-time-btn px-2 py-1 text-xs rounded bg-gray-200 dark:bg-slate-600">17:00</button>
                    <button onclick="setPMTime(this, 'pm25', '21:00')" class="pm25-time-btn px-2 py-1 text-xs rounded bg-gray-200 dark:bg-slate-600">21:00</button>
                  </div>


                  <div class="color-bar-pm25 w-full h-3 rounded mb-1"></div>
                  <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400 mono"><span>0</span><span>35</span><span>150+</span></div>
                </div>
              </div>

              <!-- PM10 -->
              <div class="p-3 rounded-lg bg-gray-50 dark:bg-slate-700/50 space-y-2">
                <label class="flex items-center justify-between cursor-pointer">
                  <span class="flex items-center gap-2 text-sm">
                    <svg class="w-4 h-4 text-rose-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" />
                    </svg>
                    PM10 Heatmap
                  </span>
                  <div class="relative">
                    <input type="checkbox" id="layer-pm10" onchange="toggleLayer('pm10')" class="sr-only peer">
                    <div class="w-9 h-5 bg-gray-300 dark:bg-slate-600 rounded-full peer-checked:bg-rose-500 transition-colors toggle-track"></div>
                    <div class="absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full shadow peer-checked:translate-x-4 transition-transform toggle-thumb"></div>
                  </div>
                </label>
                <div id="pm10-options" class="hidden space-y-2">
                  <div class="flex gap-1">
                    <button onclick="setPMDate(this, 'pm10', 'oct3')" class="pm10-date-btn flex-1 px-2 py-1 text-xs rounded bg-rose-500 text-white">Oct 3</button>
                    <button onclick="setPMDate(this, 'pm10', 'oct4')" class="pm10-date-btn flex-1 px-2 py-1 text-xs rounded bg-gray-200 dark:bg-slate-600">Oct 4</button>
                  </div>
                  <div class="grid grid-cols-4 gap-1">
                    <button onclick="setPMTime(this, 'pm10', '08:00')" class="pm10-time-btn px-2 py-1 text-xs rounded bg-rose-500 text-white">8:00</button>
                    <button onclick="setPMTime(this, 'pm10', '12:00')" class="pm10-time-btn px-2 py-1 text-xs rounded bg-gray-200 dark:bg-slate-600">12:00</button>
                    <button onclick="setPMTime(this, 'pm10', '17:00')" class="pm10-time-btn px-2 py-1 text-xs rounded bg-gray-200 dark:bg-slate-600">17:00</button>
                    <button onclick="setPMTime(this, 'pm10', '21:00')" class="pm10-time-btn px-2 py-1 text-xs rounded bg-gray-200 dark:bg-slate-600">21:00</button>
                  </div>
                  <div class="color-bar-pm10 h-2 rounded-full"></div>
                  <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400 mono"><span>0</span><span>50</span><span>250+</span></div>
                </div>
              </div>
            </div>

            <!-- Divider -->
            <div class="h-px bg-gray-200 dark:bg-slate-700"></div>

            <!-- Basemap Selection (Urban) -->
            <div class="space-y-2">
              <h3 class="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                </svg>
                Basemap
              </h3>
              <div class="flex gap-2">
                <button onclick="setBasemap('light')" id="basemap-light"
                  class="flex-1 p-2 rounded-lg border-2 border-emerald-500 bg-gray-100 dark:bg-slate-200 transition-all">
                  <div class="text-xs font-medium text-gray-700">Light</div>
                </button>

                <button onclick="setBasemap('osm')" id="basemap-osm"
                  class="flex-1 p-2 rounded-lg border-2 border-transparent bg-gray-100 dark:bg-slate-200 transition-all hover:border-emerald-400">
                  <div class="text-xs font-medium text-gray-700">OpenStreetMap</div>
                </button>
              </div>
            </div>
          </div>


        </aside>

      <!-- Map Container -->
      <div id="urban-map-wrap" class="flex-1 relative z-0">
        <div id="urban-map" class="absolute inset-0"></div>
      </div>

        <!-- ✅ Mobile buttons MUST be outside #left-panel so transforms don’t hide them -->
        <button id="urban-panel-toggle-btn" onclick="toggleLeftPanel()"
          class="hidden fixed bottom-6 left-6 md:hidden w-12 h-12 bg-emerald-500 hover:bg-emerald-600 text-white rounded-full shadow-lg flex items-center justify-center transition-all z-[2000]">
          <svg id="panel-toggle-icon" class="w-6 h-6 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
          </svg>
        </button>

        <button id="urban-open-panel-btn" onclick="openMobilePanel()"
          class="hidden md:hidden fixed bottom-6 left-6 z-[2000] w-12 h-12 bg-emerald-500 hover:bg-emerald-600 text-white rounded-full shadow-lg flex items-center justify-center transition-all hidden">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
          </svg>
        </button>
      </div>

      <!-- Ground Sensor Explorer (FIXED LAYOUT: aside + map are siblings) -->
      <div id="sensor-explorer" class="absolute inset-0 flex hidden">
        <!-- Left Panel - Sensor Controls -->
        <aside id="sensor-left-panel" class="w-80 flex-shrink-0 bg-white dark:bg-slate-800 border-r border-gray-200 dark:border-slate-700 flex flex-col overflow-hidden panel-slide z-[1500]">
          <div class="flex-1 overflow-y-auto p-4 space-y-4">

            <!-- Sensor Types -->
            <div class="space-y-2">
              <h3 class="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z" />
                </svg>
                Sensor Networks
              </h3>

              <!-- AirGradient Sensors -->
              <div class="p-3 rounded-lg bg-gray-50 dark:bg-slate-700/50 space-y-2">
                <label class="flex items-center justify-between cursor-pointer">
                  <span class="flex items-center gap-2 text-sm">
                    <div class="w-3 h-3 rounded-full bg-emerald-500"></div>
                    AirGradient Sensors
                  </span>
                  <div class="relative">
                    <input type="checkbox" id="sensor-airgradient" onchange="toggleSensorLayer('airgradient')" checked class="sr-only peer">
                    <div class="w-9 h-5 bg-gray-300 dark:bg-slate-600 rounded-full peer-checked:bg-emerald-500 transition-colors toggle-track"></div>
                    <div class="absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full shadow peer-checked:translate-x-4 transition-transform toggle-thumb"></div>
                  </div>
                </label>
                <p class="text-xs text-gray-500 dark:text-gray-400">Deployed sensors for real-time monitoring</p>
              </div>

              <!-- DENR/EMB Sensors -->
              <div class="p-3 rounded-lg bg-gray-50 dark:bg-slate-700/50 space-y-2">
                <label class="flex items-center justify-between cursor-pointer">
                  <span class="flex items-center gap-2 text-sm">
                    <div class="w-3 h-3 rounded-full bg-blue-500"></div>
                    DENR-EMB Sensors
                  </span>
                  <div class="relative">
                    <input type="checkbox" id="sensor-denr" onchange="toggleSensorLayer('denr')" checked class="sr-only peer">
                    <div class="w-9 h-5 bg-gray-300 dark:bg-slate-600 rounded-full peer-checked:bg-blue-500 transition-colors toggle-track"></div>
                    <div class="absolute left-0.5 top-0.5 w-4 h-4 bg-white rounded-full shadow peer-checked:translate-x-4 transition-transform toggle-thumb"></div>
                  </div>
                </label>
                <p class="text-xs text-gray-500 dark:text-gray-400">Auxiliary ground sensors from DENR-EMB</p>
              </div>
            </div>

            <!-- Divider -->
            <div class="h-px bg-gray-200 dark:bg-slate-700"></div>

            <!-- Sensor Locations List -->
            <div id="sensor-locations" class="hidden space-y-2">
              <h3 class="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
                Sensor Locations
              </h3>
              <div id="sensor-list" class="space-y-2"></div>
            </div>

            <!-- Divider -->
            <div class="h-px bg-gray-200 dark:bg-slate-700"></div>

            <!-- Basemap (Sensors) -->
            <div class="space-y-2">
              <h3 class="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                </svg>
                Basemap
              </h3>

              <div class="flex gap-2">
                <button onclick="setBasemap('light')" id="basemap-light-sensor"
                  class="flex-1 p-2 rounded-lg border-2 border-emerald-500 bg-gray-100 dark:bg-slate-200 transition-all">
                  <div class="text-xs font-medium text-gray-700">Light</div>
                </button>

                <button onclick="setBasemap('osm')" id="basemap-osm-sensor"
                  class="flex-1 p-2 rounded-lg border-2 border-transparent bg-gray-100 dark:bg-slate-200 transition-all hover:border-emerald-400">
                  <div class="text-xs font-medium text-gray-700">OpenStreetMap</div>
                </button>
              </div>
            </div>

          </div>
        </aside>


        <button id="sensor-panel-toggle-btn" onclick="toggleSensorLeftPanel()"
          class="fixed bottom-6 left-6 md:hidden w-12 h-12 bg-cyan-500 hover:bg-cyan-600 text-white rounded-full shadow-lg flex items-center justify-center transition-all z-[2000]">
          <svg id="sensor-panel-toggle-icon" class="w-6 h-6 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
          </svg>
        </button>

        <button id="sensor-open-panel-btn" onclick="openSensorMobilePanel()"
          class="hidden md:hidden fixed bottom-6 left-6 z-[2000] w-12 h-12 bg-cyan-500 hover:bg-cyan-600 text-white rounded-full shadow-lg flex items-center justify-center transition-all hidden">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
          </svg>
        </button>

        <!-- Map Container (SIBLING of aside) -->
        <div class="flex-1 relative">
          <!-- Force map behind overlays -->
          <div id="sensor-map" class="absolute inset-0 z-0"></div>

          <!-- Sensor Detail Panel (force above Leaflet panes/controls) -->
          <div id="sensor-detail" class="absolute top-4 right-4 z-[1200] pointer-events-auto hidden">
            <div class="bg-white/95 dark:bg-slate-800/95 backdrop-blur-sm rounded-xl shadow-lg p-4 w-72">
              <div class="flex items-center justify-between mb-3">
                <h3 id="sensor-name" class="font-semibold">Sensor Name</h3>
                <button onclick="closeSensorDetail()" class="p-1 rounded hover:bg-gray-100 dark:hover:bg-slate-700">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>

              <div class="space-y-3">
                <div class="grid grid-cols-2 gap-3">
                  <div class="p-3 rounded-lg bg-purple-50 dark:bg-purple-900/20">
                    <div class="text-xs text-purple-600 dark:text-purple-400 mb-1">PM2.5</div>
                    <div class="text-xl font-bold mono" id="detail-pm25">--</div>
                    <div class="text-xs text-gray-500">µg/m³</div>
                  </div>
                  <div class="p-3 rounded-lg bg-rose-50 dark:bg-rose-900/20">
                    <div class="text-xs text-rose-600 dark:text-rose-400 mb-1">PM10</div>
                    <div class="text-xl font-bold mono" id="detail-pm10">--</div>
                    <div class="text-xs text-gray-500">µg/m³</div>
                  </div>
                </div>

                <div class="grid grid-cols-2 gap-3">
                  <div class="p-3 rounded-lg bg-orange-50 dark:bg-orange-900/20">
                    <div class="text-xs text-orange-600 dark:text-orange-400 mb-1">Temperature</div>
                    <div class="text-xl font-bold mono" id="detail-temp">--</div>
                    <div class="text-xs text-gray-500">°C</div>
                  </div>
                  <div class="p-3 rounded-lg bg-cyan-50 dark:bg-cyan-900/20">
                    <div class="text-xs text-cyan-600 dark:text-cyan-400 mb-1">Humidity</div>
                    <div class="text-xl font-bold mono" id="detail-humidity">--</div>
                    <div class="text-xs text-gray-500">%</div>
                  </div>
                </div>

                <div class="text-xs text-gray-500 dark:text-gray-400">
                  <div>Location: <span id="detail-location" class="mono">--</span></div>
                  <div>Last Update: <span id="detail-update" class="mono">--</span></div>
                </div>

                <div class="mt-3 space-y-2">
                  <div class="grid grid-cols-2 gap-2">
                    <div>
                      <label class="text-[11px] text-gray-500 dark:text-gray-400">Measurement</label>
                      <select id="ts-metric"
                        class="mt-1 w-full rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-900 px-2 py-1 text-xs">
                        <option value="pm25">PM2.5</option>
                        <option value="pm10">PM10</option>
                        <option value="humidity">Humidity</option>
                        <option value="temperature">Temperature</option>
                      </select>
                    </div>

                    <div class="flex items-end">
                      <button id="ts-apply"
                        class="w-full px-3 py-2 rounded-lg bg-cyan-500 hover:bg-cyan-600 text-white text-xs font-medium transition-colors">
                        Apply
                      </button>
                    </div>
                  </div>

                  <div class="grid grid-cols-2 gap-2">
                    <div>
                      <label class="text-[11px] text-gray-500 dark:text-gray-400">From</label>
                      <input id="ts-from" type="datetime-local"
                        class="mt-1 w-full rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-900 px-2 py-1 text-xs" />
                    </div>
                    <div>
                      <label class="text-[11px] text-gray-500 dark:text-gray-400">To</label>
                      <input id="ts-to" type="datetime-local"
                        class="mt-1 w-full rounded-lg border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-900 px-2 py-1 text-xs" />
                    </div>
                  </div>

                  <div class="pt-2 h-40">
                    <canvas id="ts-chart" class="w-full h-full"></canvas>
                  </div>

                </div>              

              </div>

            </div>
          </div>
        </div>
      </div>

    </main>
  </div>

  <script>


    // =====================
    // Landing Page Controls
    // =====================
    function hideLanding() {
      const landing = document.getElementById('landing');
      const header = document.getElementById('main-header');
      if (landing) landing.classList.add('hidden');
      if (header) header.classList.remove('hidden');
      syncMobileHomeVisibility();
    }

    function showLanding() {
      const landing = document.getElementById('landing');
      const header = document.getElementById('main-header');
      if (landing) landing.classList.remove('hidden');
      if (header) header.classList.add('hidden');
      syncMobileHomeVisibility();
    }

    function enterApp(tab) {
      hideLanding();
      switchTab(tab);
    
      if (tab === 'urban') refreshUrbanMap();

      setTimeout(async () => {
      if (tab === 'urban' && urbanMap) {
        urbanMap.invalidateSize();
        if (state.layers.buildings) await updateBuildingLayer();
      }
        if (tab === 'sensors' && sensorMap) sensorMap.invalidateSize();
      }, 150);
    }

    function showAbout() {
      const about = document.getElementById('about');
      const landing = document.getElementById('landing');
      const header = document.getElementById('main-header');
      if (landing) landing.classList.add('hidden');
      if (about) about.classList.remove('hidden');
      if (header) header.classList.add('hidden');
      syncMobileHomeVisibility();
    }

    function hideAbout() {
      const about = document.getElementById('about');
      if (about) about.classList.add('hidden');
      showLanding();
    }

    function backToHomeFromAbout() {
      hideAbout();
    }

    // =====================
    // State Management
    // =====================
    const state = {
      currentTab: 'urban',
      viewMode: 'all',
      selectedCity: null,
      darkMode: false,
      basemap: 'light',
      layers: { buildings: true, streets: false, lst: false, pm25: false, pm10: false },
      streetOptions: { canyon: false, highway: false },
      sensorLayers: { airgradient: true, denr: false },
      pm25: { date: 'oct3', time: '08:00' },
      pm10: { date: 'oct3', time: '08:00' }
    };

    // =====================
    // City Data
    // =====================
    const cities = {
      lawton:  { name:'Lawton',  center:null, zoom:16, color:'#f43f5e', buildingFile:'lawton',  streetFile:'lawton',  lstFile: 'lawton' },
      pasay:   { name:'Pasay',   center:null, zoom:16, color:'#f59e0b', buildingFile:'pasay',   streetFile:'pasay',   lstFile: 'pasay' },
      gateway: { name:'Gateway', center:null, zoom:16, color:'#06b6d4', buildingFile:'gateway', streetFile:'gateway', lstFile: 'gateway' },
      ayala:   { name:'Ayala',   center:null, zoom:16, color:'#8b5cf6', buildingFile:'ayala',   streetFile:'ayala',   lstFile: 'ayala' }
    };


    // =====================
    // Sensor Stations (AirGradient) - CSV-backed
    // =====================
    const sensorStations = {
      rqahs: {
        key: "rqahs",
        name: "RQAHS",
        type: "airgradient",
        coords: [14.5937209191783, 120.98946176339179],
        file: "RQAHS_edited.csv",
      },
      cubao: {
        key: "cubao",
        name: "Cubao",
        type: "airgradient",
        coords: [14.62281123659132, 121.05284446539522],
        file: "Cubao_edited.csv",
      },
      pasay: {
        key: "pasay",
        name: "Pasay",
        type: "airgradient",
        coords: [14.538834332403257, 121.00650024808574],
        file: "Pasay_edited.csv",
      },
      las_pinas: {
        key: "las_pinas",
        name: "Las Pinas",
        type: "airgradient",
        coords: [14.436799012857355, 120.99839891592009],
        file: "Las Pinas_edited.csv",
      },
      valenzuela: {
        key: "valenzuela",
        name: "Valenzuela",
        type: "airgradient",
        coords: [14.691400200380853, 120.9738371412875],
        file: "Valenzuela_edited.csv",
      },
    };


    // =====================
    // LST (GeoTIFF) Globals
    // =====================
    const lstBlues10 = [
      '#f7fbff', '#e3eef8', '#cfe1f2', '#aecdE6', '#83b8da',
      '#5aa2cf', '#3589c0', '#1b6fb2', '#08519c', '#08306b'
    ];

    let lstLayers = {};          // { cityKey: GeoRasterLayer }
    let lstRasterCache = {};     // { cityKey: georaster }
    let globalLSTBreaks = null;  // breaks for "all cities"
    let cityLSTBreaks = {};      // { cityKey: breaks[] }

    // =====================
    // PM2.5 (GeoTIFF) Globals
    // =====================
    let pm25Layers = {};                 // { cityKey: GeoRasterLayer }
    let pm25RasterCache = {};            // { dateKey: { cityKey: { timeKey: georaster } } }
    let globalPM25Breaks = {};           // { dateKey: { timeKey: breaks[] } }
    let cityPM25Breaks = {};             // { dateKey: { timeKey: { cityKey: breaks[] } } }

    // Map your city keys -> XX codes
    const PM25_CITY_CODE = {
      pasay: "PL",
      gateway: "CL",   // Cubao (your "gateway" study area)
      ayala: "AL",
      lawton: "LL",
    };

    // AQI-like color stops (green -> yellow -> orange -> red -> purple -> maroon)
    const PM25_STOPS = ["#00e400", "#ffff00", "#ff7e00", "#ff0000", "#8f3f97", "#7e0023"];

    // Linear interpolate between two hex colors
    function lerpColor(hex1, hex2, t) {
      const a = hexToRgb(hex1);
      const b = hexToRgb(hex2);
      return rgbToHex(
        Math.round(a.r + (b.r - a.r) * t),
        Math.round(a.g + (b.g - a.g) * t),
        Math.round(a.b + (b.b - a.b) * t)
      );
    }

    // Build an n-color ramp across multiple stops
    function makeMultiStopRamp(stops, n) {
      if (!stops?.length) return [];
      if (n <= 1) return [stops[stops.length - 1]];

      const segs = stops.length - 1;
      const out = [];

      for (let i = 0; i < n; i++) {
        const u = i / (n - 1);              // 0..1
        const p = u * segs;                 // 0..segs
        const si = Math.min(segs - 1, Math.floor(p));
        const tt = p - si;
        out.push(lerpColor(stops[si], stops[si + 1], tt));
      }
      return out;
    }
    // =====================
    // Maps Initialization
    // =====================
    let urbanMap, sensorMap;
    let basemapLayers = {};
    let cityMarkers = {};
    let buildingLayers = {};
    let streetLayers = {};
    let sensorMarkers = {};

    let buildingDataCache = {};
    let globalBreaks = null;
    let cityBreaks = {};


    // 10-class Reds palette (light -> dark)
    const canyonReds = [
      '#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a',
      '#ef3b2c', '#cb181d', '#a50f15', '#67000d', '#3b0007'
    ];

    let globalCanyonBreaks = null;
    let cityCanyonBreaks = {}; // { cityKey: breaks[] }

    let streetDataCache = {};     // { cityKey: FeatureCollection }

    // =====================
    // FIX: Track pending moveend to cancel stale handlers
    // =====================
    let pendingMoveEndCityKey = null;

    // 10-class grey color scheme (light to dark grey)
    const buildingColors = [
      '#ffffff', '#f0f0f0', '#d9d9d9', '#bfbfbf', '#a6a6a6',
      '#8c8c8c', '#737373', '#595959', '#404040', '#262626'
    ];

    const basemaps = {
      light: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
      osm:   'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'
    };

    async function initMaps() {
      await initializeCityCenters();

      document.documentElement.style.setProperty('--control-bg', '#ffffff');
      document.documentElement.style.setProperty('--control-text', '#1f2937');
      document.documentElement.style.setProperty('--control-border', '#e5e7eb');

      const attribution =
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' +
        ' &copy; <a href="https://carto.com/">CARTO</a>';

      const initialCenter = calculateGlobalBuildingCentroid();
      
      urbanMap = L.map('urban-map', { center: initialCenter, zoom: 12, zoomControl: false });
      L.control.zoom({ position: 'bottomleft' }).addTo(urbanMap);

      urbanMap.createPane('buildingsPane');
      urbanMap.getPane('buildingsPane').style.zIndex = 450;

      const startBasemap = basemaps[state.basemap] ? state.basemap : 'light';

      basemapLayers.urban = L.tileLayer(basemaps[startBasemap], {
        attribution,
        maxZoom: 19
      }).addTo(urbanMap);

      // City markers
      Object.entries(cities).forEach(([key, city]) => {
        if (city.center) {
          const marker = L.circleMarker(city.center, {
            radius: 8,
            fillColor: city.color,
            color: '#fff',
            weight: 2,
            opacity: 1,
            fillOpacity: 0.8
          }).addTo(urbanMap);

          marker.bindTooltip(city.name, { permanent: false, direction: 'top', className: 'custom-tooltip' });
          cityMarkers[key] = marker;
        }
      });

      const bounds = Object.values(cities)
        .filter(city => city.center)
        .map(city => city.center);
      if (bounds.length > 0) {
        urbanMap.fitBounds(bounds, { padding: [50, 50] });
      }

      // Sensor Map
      sensorMap = L.map('sensor-map', { center: initialCenter, zoom: 12, zoomControl: false });
      L.control.zoom({ position: 'bottomleft' }).addTo(sensorMap);

      basemapLayers.sensor = L.tileLayer(basemaps[startBasemap], {
        attribution,
        maxZoom: 19
      }).addTo(sensorMap);

      await initSensorMarkers();
      updateSensorLocationsList();
    }

    function zoomToAllCities() {
      if (!urbanMap) return;

      const latlngs = Object.values(cities)
        .filter(c => c.center)
        .map(c => c.center);

      if (latlngs.length === 0) return;

      urbanMap.fitBounds(latlngs, {
        padding: [50, 50],
        animate: true,
        duration: 0.8
      });
    }


function hexToRgb(hex) {
  const h = hex.replace('#', '');
  const bigint = parseInt(h.length === 3 ? h.split('').map(c=>c+c).join('') : h, 16);
  return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
}

function rgbToHex(r, g, b) {
  const toHex = (x) => x.toString(16).padStart(2, '0');
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

// linear ramp from light -> medium blue (no dark/navy hues)
function makeBlueRamp(n) {
  const start = hexToRgb('#f7fbff'); // very light
  const end   = hexToRgb('#1d6fb8'); // slightly darker blue (not navy)
  const out = [];
  for (let i = 0; i < n; i++) {
    const t = n === 1 ? 1 : i / (n - 1);
    const r = Math.round(start.r + (end.r - start.r) * t);
    const g = Math.round(start.g + (end.g - start.g) * t);
    const b = Math.round(start.b + (end.b - start.b) * t);
    out.push(rgbToHex(r, g, b));
  }
  return out;
}

// linear ramp from very light green -> deep "UNG-like" green
function makeGreenRamp(n) {
  const start = hexToRgb('#f0fdf4'); // very light green
  const end   = hexToRgb('#14532d'); // deep green
  const out = [];
  for (let i = 0; i < n; i++) {
    const t = n === 1 ? 1 : i / (n - 1);
    const r = Math.round(start.r + (end.r - start.r) * t);
    const g = Math.round(start.g + (end.g - start.g) * t);
    const b = Math.round(start.b + (end.b - start.b) * t);
    out.push(rgbToHex(r, g, b));
  }
  return out;
}

async function calculateCityPM25Breaks(cityKey, dateKey, timeKey) {
  const georaster = await loadPM25Raster(cityKey, dateKey, timeKey);
  if (!georaster) return null;

  const vals = sampleRasterValues(georaster, 60000);
  return calculateJenksBreaks(vals, 100); // ✅ 100 classes
}

async function calculateGlobalPM25Breaks(dateKey, timeKey) {
  const all = [];
  for (const cityKey of Object.keys(cities)) {
    const georaster = await loadPM25Raster(cityKey, dateKey, timeKey);
    if (!georaster) continue;
    all.push(...sampleRasterValues(georaster, 25000));
  }
  return calculateJenksBreaks(all, 100); // ✅ 100 classes
}

function makeRedRamp(n) {
  const start = hexToRgb('#fff5f0'); // very light
  const end   = hexToRgb('#ef3b2c'); // medium red (stops before super dark)
  const out = [];
  for (let i = 0; i < n; i++) {
    const t = n === 1 ? 1 : i / (n - 1);
    out.push(rgbToHex(
      Math.round(start.r + (end.r - start.r) * t),
      Math.round(start.g + (end.g - start.g) * t),
      Math.round(start.b + (end.b - start.b) * t)
    ));
  }
  return out;
}

function setLegendGradient(el, colors) {
  if (!el || !colors?.length) return;
  el.style.background = `linear-gradient(to right, ${colors.join(',')})`;
}


async function initSensorMarkers() {
  // clear existing markers if any
  Object.values(sensorMarkers).forEach(m => {
    try { sensorMap.removeLayer(m); } catch {}
  });
  sensorMarkers = {};

  for (const [key, st] of Object.entries(sensorStations)) {
    const color = "#10b981"; // AirGradient green

    // Load series so tooltip can show latest values
    const ts = await loadStationTimeSeries(key);
    const latest = ts?.rows?.length ? ts.rows[ts.rows.length - 1] : null;

    const marker = L.circleMarker(st.coords, {
      radius: 10,
      fillColor: color,
      color: "#fff",
      weight: 2,
      opacity: 1,
      fillOpacity: 0.9
    }).addTo(sensorMap);

    const pm25 = latest?.pm25;
    const pm10 = latest?.pm10;

    marker.bindTooltip(`
      <div class="p-2">
        <div class="font-semibold">${st.name}</div>
        <div class="text-xs">PM2.5: ${pm25 != null ? pm25.toFixed(0) : "--"} µg/m³</div>
        <div class="text-xs">PM10: ${pm10 != null ? pm10.toFixed(0) : "--"} µg/m³</div>
      </div>
    `, { direction: "top" });

    marker.on("click", () => showSensorDetail(key));
    sensorMarkers[key] = marker;
  }
}

    // =====================
    // Tab Navigation
    // =====================
    function switchTab(tab) {
      state.currentTab = tab;

      const urbanExplorer = document.getElementById('urban-explorer');
      const sensorExplorer = document.getElementById('sensor-explorer');

      urbanExplorer.classList.toggle('hidden', tab !== 'urban');
      sensorExplorer.classList.toggle('hidden', tab !== 'sensors');

      // ✅ Automatically close the panel of the tab you're leaving (mobile only)
      if (window.innerWidth < 768) {
        if (tab === 'urban') {
          // Close sensor panel
          document.getElementById('sensor-left-panel')?.classList.add('mobile-hidden-sensor');
          document.getElementById('sensor-panel-toggle-btn')?.classList.add('hidden');
          document.getElementById('sensor-open-panel-btn')?.classList.remove('hidden');
        } else {
          // Close urban panel
          document.getElementById('left-panel')?.classList.add('mobile-hidden');
          document.getElementById('urban-panel-toggle-btn')?.classList.add('hidden');
          document.getElementById('urban-open-panel-btn')?.classList.remove('hidden');
        }
      }

      // Update tab highlight
      updateTabUI(tab);

      if (tab === 'urban') {
        setTimeout(async () => {
          urbanMap && urbanMap.invalidateSize();
          if (state.layers.pm25) await updatePM25Layer();
        }, 120);
        refreshUrbanMap();
        
      } else {
        setTimeout(() => sensorMap && sensorMap.invalidateSize(), 60);
      }

      handleResponsivePanels();
      syncFloatingButtonsVisibility();
    }

    function openMobilePanel() {
      const panel = document.getElementById('left-panel');
      const openBtn = document.getElementById('urban-open-panel-btn');
      const toggleBtn = document.getElementById('urban-panel-toggle-btn');
      panel.classList.remove('mobile-hidden');
      openBtn.classList.add('hidden');
      toggleBtn.classList.remove('hidden');
      refreshUrbanMap();
    }

    function closeMobilePanel() {
      const panel = document.getElementById('left-panel');
      const openBtn = document.getElementById('urban-open-panel-btn');
      const toggleBtn = document.getElementById('urban-panel-toggle-btn');
      panel.classList.add('mobile-hidden');
      toggleBtn.classList.add('hidden');
      openBtn.classList.remove('hidden');
      refreshUrbanMap();
    }
    // =====================
    // View Mode & City Selection
    // =====================
    async function setViewMode(mode, force = false) {
      state.viewMode = mode;

      const allBtn = document.getElementById('view-all-btn');
      const singleBtn = document.getElementById('view-single-btn');

      if (mode === 'all') {
        allBtn.classList.add('bg-emerald-500', 'text-white');
        allBtn.classList.remove('text-gray-600', 'dark:text-gray-300');
        singleBtn.classList.remove('bg-emerald-500', 'text-white');
        singleBtn.classList.add('text-gray-600', 'dark:text-gray-300');

        // FIX 1: Cancel any pending single-city moveend handler
        pendingMoveEndCityKey = null;

        state.selectedCity = null;
        document.querySelectorAll('.city-btn').forEach(btn =>
          btn.classList.remove('border-emerald-500')
        );

        if (force && urbanMap) zoomToAllCities();

        if (state.layers.buildings) {
          if (!globalBreaks) globalBreaks = calculateGlobalBreaks();
          updateBuildingLegend(globalBreaks);
        }

        if (force && state.layers.buildings) {
          globalBreaks = null;
          await updateBuildingLayer();
        }

      } else {
        singleBtn.classList.add('bg-emerald-500', 'text-white');
        singleBtn.classList.remove('text-gray-600', 'dark:text-gray-300');
        allBtn.classList.remove('bg-emerald-500', 'text-white');
        allBtn.classList.add('text-gray-600', 'dark:text-gray-300');

        if (state.layers.buildings && state.selectedCity) {
          if (!cityBreaks[state.selectedCity]) {
            cityBreaks[state.selectedCity] = calculateCityBreaks(state.selectedCity);
          }
          updateBuildingLegend(cityBreaks[state.selectedCity]);
        }
      }

      // ✅ refresh streets once (applies to both modes)
      if (state.layers.streets) {
        await updateStreetLayer();
      }

      // ✅ ADD THIS RIGHT HERE (very end)
      if (state.layers.lst) {
        await updateLSTLayer();
      }

      // ✅ add PM2.5 refresh
      if (state.layers.pm25) {
        await updatePM25Layer();
      }
    }

  function openSensorMobilePanel() {
    const panel = document.getElementById('sensor-left-panel');
    const openBtn = document.getElementById('sensor-open-panel-btn');
    const toggleBtn = document.getElementById('sensor-panel-toggle-btn');
    panel?.classList.remove('mobile-hidden-sensor');
    openBtn?.classList.add('hidden');
    toggleBtn?.classList.remove('hidden');
    if (state.currentTab === 'sensors') setTimeout(() => sensorMap?.invalidateSize(), 60);
  }

  function closeSensorMobilePanel() {
    const panel = document.getElementById('sensor-left-panel');
    const openBtn = document.getElementById('sensor-open-panel-btn');
    const toggleBtn = document.getElementById('sensor-panel-toggle-btn');
    panel?.classList.add('mobile-hidden-sensor');
    toggleBtn?.classList.add('hidden');
    openBtn?.classList.remove('hidden');
    if (state.currentTab === 'sensors') setTimeout(() => sensorMap?.invalidateSize(), 60);
  }

  function toggleSensorLeftPanel() {
    const panel = document.getElementById('sensor-left-panel');
    const isHidden = panel?.classList.contains('mobile-hidden-sensor');
    if (isHidden) openSensorMobilePanel();
    else closeSensorMobilePanel();
  }

  function handleResponsivePanels() {
    // Urban
    {
      const panel = document.getElementById('left-panel');
      const openBtn = document.getElementById('urban-open-panel-btn');
      const toggleBtn = document.getElementById('urban-panel-toggle-btn');

      if (panel) {
        if (window.innerWidth >= 768) {
          panel.classList.remove('mobile-hidden');
          openBtn?.classList.add('hidden');
          toggleBtn?.classList.add('hidden');
        } else {
          const isHidden = panel.classList.contains('mobile-hidden');
          if (isHidden) { toggleBtn?.classList.add('hidden'); openBtn?.classList.remove('hidden'); }
          else { openBtn?.classList.add('hidden'); toggleBtn?.classList.remove('hidden'); }
        }
      }
    }

    // Sensors
    {
      const panel = document.getElementById('sensor-left-panel');
      const openBtn = document.getElementById('sensor-open-panel-btn');
      const toggleBtn = document.getElementById('sensor-panel-toggle-btn');

      // ✅ Hide sensor floating buttons unless Sensors tab is active
      if (state.currentTab !== 'sensors') {
        openBtn?.classList.add('hidden');
        toggleBtn?.classList.add('hidden');
        return;
      }

      if (panel) {
        if (window.innerWidth >= 768) {
          panel.classList.remove('mobile-hidden-sensor');
          openBtn?.classList.add('hidden');
          toggleBtn?.classList.add('hidden');
        } else {
          const isHidden = panel.classList.contains('mobile-hidden-sensor');
          if (isHidden) { toggleBtn?.classList.add('hidden'); openBtn?.classList.remove('hidden'); }
          else { openBtn?.classList.add('hidden'); toggleBtn?.classList.remove('hidden'); }
        }
      }
    }

    // Refresh whichever map is visible
    if (state.currentTab === 'urban') refreshUrbanMap();
    if (state.currentTab === 'sensors') setTimeout(() => sensorMap?.invalidateSize(), 60);
    syncFloatingButtonsVisibility();
  }

  window.addEventListener('resize', handleResponsivePanels);



    async function selectCity(cityKey) {
      if (state.viewMode === 'all') await setViewMode('single');

      state.selectedCity = cityKey;

      // FIX 2: Track which city's flyTo is active so stale handlers can self-cancel
      pendingMoveEndCityKey = cityKey;

      const city = cities[cityKey];

      document.querySelectorAll('.city-btn').forEach(btn => btn.classList.remove('border-emerald-500'));
      const btn = document.querySelector(`[data-city="${cityKey}"]`);
      if (btn) btn.classList.add('border-emerald-500');

      urbanMap.flyTo(city.center, city.zoom, { duration: 1 });

      urbanMap.once('moveend', async () => {
        if (pendingMoveEndCityKey !== cityKey) return;
        if (state.viewMode !== 'single') return;
        if (state.selectedCity !== cityKey) return;
        pendingMoveEndCityKey = null;

        if (state.layers.buildings) await updateBuildingLayer();
        if (state.layers.lst) await updateLSTLayer();
        if (state.layers.streets) await updateStreetLayer();
        if (state.layers.pm25) await updatePM25Layer();
      });
    }


function updateTabUI(tab) {
  const urbanTab = document.getElementById('tab-urban');
  const sensorTab = document.getElementById('tab-sensors');
  if (!urbanTab || !sensorTab) return;

  // Base classes for unselected tabs
  const base = [
    'tab-btn', 'px-4', 'py-2', 'rounded-md', 'text-sm', 'font-medium',
    'transition-all', 'hover:bg-gray-50', 'dark:hover:bg-slate-600'
  ];

  // Selected tab classes (includes the "white outline")
  const selected = [
    'bg-white', 'dark:bg-slate-600',
    'text-gray-900', 'dark:text-white',
    'shadow-sm',
    'ring-2', 'ring-white', 'ring-offset-2',
    'ring-offset-gray-100', 'dark:ring-offset-slate-700'
  ];

  // Unselected tab classes
  const unselected = [
    'text-gray-600', 'dark:text-gray-300'
  ];

  function setBtn(btn, isSelected) {
    btn.className = ''; // reset
    btn.classList.add(...base);
    if (isSelected) btn.classList.add(...selected);
    else btn.classList.add(...unselected);
  }

  setBtn(urbanTab, tab === 'urban');
  setBtn(sensorTab, tab === 'sensors');
}

    // =====================
    // Layer Controls (Urban)
    // =====================
    async function toggleLayer(layer) {
      const checkbox = document.getElementById(`layer-${layer}`);
      state.layers[layer] = checkbox ? checkbox.checked : !state.layers[layer];

      if (layer === 'buildings') {
        document.getElementById('building-legend').classList.toggle('hidden', !state.layers[layer]);
        await updateBuildingLayer();
      } else if (layer === 'streets') {
        document.getElementById('street-options').classList.toggle('hidden', !state.layers[layer]);
        await updateStreetLayer();
      } else if (layer === 'lst') {
        document.getElementById('lst-legend').classList.toggle('hidden', !state.layers[layer]);
        updateLSTLayer();
      } else if (layer === 'pm25') {
        document.getElementById('pm25-options').classList.toggle('hidden', !state.layers[layer]);
        updatePM25Layer();
      } else if (layer === 'pm10') {
        document.getElementById('pm10-options').classList.toggle('hidden', !state.layers[layer]);
        updatePM10Layer();
      }
    }

    async function toggleStreetOption(option) {
      state.streetOptions[option] = !state.streetOptions[option];

      if (option === 'canyon') {
        document.getElementById('canyon-legend').classList.toggle('hidden', !state.streetOptions[option]);
      } else if (option === 'highway') {
        document.getElementById('highway-legend').classList.toggle('hidden', !state.streetOptions[option]);
      }

      await updateStreetLayer();
    }

    // =====================
    // Load All Building Data
    // =====================
    async function loadAllBuildingData() {
      const base = new URL('.', window.location.href);

      const loadPromises = Object.keys(cities).map(async (cityKey) => {
        const cached = buildingDataCache[cityKey];
        const hasFeatures = cached?.features?.length > 0;
        if (hasFeatures) return;

        const fileKey = cities[cityKey].buildingFile || cityKey;
        const url = new URL(`data/building_${fileKey}.geojson`, base).toString();

        try {
          console.log(`[Buildings] Fetching ${cityKey}: ${url}`);
          const res = await fetch(url, { cache: "no-store" });

          console.log(`[Buildings] ${cityKey} status:`, res.status, res.statusText);
          if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);

          const geojson = await res.json();

          const n = Array.isArray(geojson?.features) ? geojson.features.length : 0;
          console.log(`[Buildings] ${cityKey} features:`, n);

          const normalized = (() => {
            if (!geojson || typeof geojson !== "object") {
              return { type: "FeatureCollection", features: [] };
            }

            // Already a proper FeatureCollection
            if (geojson.type === "FeatureCollection" && Array.isArray(geojson.features)) {
              return geojson;
            }

            // Single Feature -> wrap it
            if (geojson.type === "Feature") {
              return { type: "FeatureCollection", features: [geojson] };
            }

            // Anything else (Topology, GeometryCollection, etc.) -> treat as empty
            console.warn(`[Buildings] ${cityKey} unexpected GeoJSON type: ${geojson.type}`);
            return { type: "FeatureCollection", features: [] };
          })();

          buildingDataCache[cityKey] = normalized;

          const f0 = geojson?.features?.[0];
          const coord0 =
            f0?.geometry?.type === "Polygon" ? f0.geometry.coordinates?.[0]?.[0] :
            f0?.geometry?.type === "MultiPolygon" ? f0.geometry.coordinates?.[0]?.[0]?.[0] :
            null;

          if (coord0) {
            const [lng, lat] = coord0;
            if (Math.abs(lat) > 90 || Math.abs(lng) > 180) {
              console.warn(`[Buildings] ${cityKey} looks NOT EPSG:4326 (lng,lat = ${lng}, ${lat}).`);
            }
          }
        } catch (err) {
          console.error(`[Buildings] Failed ${cityKey}:`, err);
          buildingDataCache[cityKey] = { type: "FeatureCollection", features: [] };
        }
      });

      await Promise.all(loadPromises);
    }

    // =====================
    // Calculate Building Centroid for a City
    // =====================
    function calculateBuildingCentroid(cityKey) {
      const geojsonData = buildingDataCache[cityKey];
      if (!geojsonData?.features?.length) {
        console.warn(`[Centroid] No features for ${cityKey}`);
        return null;
      }

      const bounds = L.latLngBounds([]);

      for (const f of geojsonData.features) {
        const g = f?.geometry;
        if (!g) continue;

        if (g.type === "Polygon") {
          const ring = g.coordinates?.[0] || [];
          for (const [lng, lat] of ring) {
            // Only accept plausible WGS84 coords
            if (Number.isFinite(lat) && Number.isFinite(lng) && Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
              bounds.extend([lat, lng]);
            }
          }
        } else if (g.type === "MultiPolygon") {
          for (const poly of g.coordinates || []) {
            const ring = poly?.[0] || [];
            for (const [lng, lat] of ring) {
              if (Number.isFinite(lat) && Number.isFinite(lng) && Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                bounds.extend([lat, lng]);
              }
            }
          }
        }
      }

      if (!bounds.isValid()) {
        console.warn(`[Centroid] Bounds invalid for ${cityKey} (check CRS / coord order)`);
        return null;
      }

      const c = bounds.getCenter();
      console.log(`[Centroid] ${cityKey}:`, [c.lat, c.lng]);
      return [c.lat, c.lng];
    }

    // =====================
    // Initialize City Centers from Building Data
    // =====================
    async function initializeCityCenters() {
      await loadAllBuildingData();
      
      Object.keys(cities).forEach(cityKey => {
        const centroid = calculateBuildingCentroid(cityKey);
        if (centroid) {
          cities[cityKey].center = centroid;
        } else {
          cities[cityKey].center = [14.5995, 121.0037];
          console.warn(`Using fallback center for ${cityKey}`);
        }
      });
    }

    // =====================
    // Calculate Jenks Breaks
    // =====================
    function calculateJenksBreaks(heights, numClasses = 10) {
      if (!heights || heights.length === 0) return null;
      
      const validHeights = heights.filter(h => h != null && !isNaN(h) && h > 0);
      if (validHeights.length === 0) return null;
      
      try {
        const breaks = ss.ckmeans(validHeights, Math.min(numClasses, validHeights.length));
        return breaks.map(cluster => Math.max(...cluster));
      } catch (error) {
        console.warn('Jenks calculation failed, using quantile breaks:', error);
        const sorted = [...validHeights].sort((a, b) => a - b);
        const breaks = [];
        for (let i = 1; i <= numClasses; i++) {
          const index = Math.floor((sorted.length * i) / numClasses) - 1;
          breaks.push(sorted[Math.max(0, index)]);
        }
        return breaks;
      }
    }

    // =====================
    // Calculate Global Breaks (All Cities)
    // =====================
    function calculateGlobalBreaks() {
      const allHeights = [];
      
      Object.entries(buildingDataCache).forEach(([cityKey, geojsonData]) => {
        if (geojsonData && geojsonData.features) {
          geojsonData.features.forEach(feature => {
            const height = feature.properties.height || 
                          feature.properties.HEIGHT || 
                          feature.properties.approxBuil || 0;
            if (height > 0) allHeights.push(height);
          });
        }
      });
      
      return calculateJenksBreaks(allHeights, 10);
    }

    // =====================
    // Calculate Per-City Breaks
    // =====================
    function calculateCityBreaks(cityKey) {
      const geojsonData = buildingDataCache[cityKey];
      if (!geojsonData || !geojsonData.features) return null;
      
      const heights = geojsonData.features.map(feature => {
        return feature.properties.height || 
              feature.properties.HEIGHT || 
              feature.properties.approxBuil || 0;
      }).filter(h => h > 0);
      
      return calculateJenksBreaks(heights, 10);
    }

    // =====================
    // Get Color Based on Height and Breaks
    // =====================
    function getColorFromBreaks(height, breaks) {
      if (!breaks || breaks.length === 0) return buildingColors[0];
      
      for (let i = 0; i < breaks.length; i++) {
        if (height <= breaks[i]) {
          return buildingColors[i];
        }
      }
      return buildingColors[buildingColors.length - 1];
    }

    // =====================
    // Create Building Layer
    // =====================
    function createBuildingLayer(cityKey, breaks) {
      const geojsonData = buildingDataCache[cityKey];
      if (!geojsonData?.features?.length) return null;

      if (!urbanMap.getPane('buildingsPane')) {
        urbanMap.createPane('buildingsPane');
        urbanMap.getPane('buildingsPane').style.zIndex = 450;
      }

      try {
        return L.geoJSON(geojsonData, {
          pane: 'buildingsPane',
          style: (feature) => {
            const hRaw =
              feature?.properties?.height ??
              feature?.properties?.HEIGHT ??
              feature?.properties?.approxBuil ??
              0;

            const height = Number(hRaw) || 0; // ensures numeric
            return {
              color: '#1f2937',
              weight: 0.5,
              fillColor: getColorFromBreaks(height, breaks),
              fillOpacity: 0.7
            };
          }
        });
      } catch (e) {
        console.error(`[Buildings] Leaflet failed to render ${cityKey}:`, e);
        return null;
      }
    }

    // =====================
    // Update Building Legend
    // =====================
    function updateBuildingLegend(breaks) {
      const legendDiv = document.getElementById('building-legend');
      if (!legendDiv) return;

      const modeIndicator = document.getElementById('legend-mode-indicator');
      if (modeIndicator) {
        modeIndicator.textContent =
          state.viewMode === 'all'
            ? 'All Cities'
            : (cities[state.selectedCity]?.name || 'Single');
      }

      if (!breaks || breaks.length === 0) return;

      const legendText = legendDiv.querySelector('.flex.justify-between.text-xs');
      if (legendText) {
        const minVal = 0;
        const midVal = breaks[Math.floor(breaks.length / 2)];
        const maxVal = breaks[breaks.length - 1];

        legendText.innerHTML = `
          <span>${minVal.toFixed(0)}m</span>
          <span>${midVal.toFixed(0)}m</span>
          <span>${maxVal.toFixed(0)}m+</span>
        `;
      }
    }

    // =====================
    // Update Building Layer
    // =====================
    async function updateBuildingLayer() {
      if (!urbanMap) return;

      if (state.layers.buildings) {
        await loadAllBuildingData();

        if (state.viewMode === "all") {
          if (!globalBreaks) {
            globalBreaks = calculateGlobalBreaks();
            console.log("Global breaks:", globalBreaks);
          }

          // Remove all existing layers first
          Object.keys(cities).forEach((cityKey) => {
            if (buildingLayers[cityKey]) {
              urbanMap.removeLayer(buildingLayers[cityKey]);
              delete buildingLayers[cityKey];
            }
          });

          // Add all cities
          Object.keys(cities).forEach((cityKey) => {
            const data = buildingDataCache[cityKey];

            if (!data || !Array.isArray(data.features) || data.features.length === 0) {
              console.warn(`[Buildings] Skipping ${cityKey} (no data / empty features)`);
              return;
            }

            buildingLayers[cityKey] = createBuildingLayer(cityKey, globalBreaks);
            if (buildingLayers[cityKey]) {
              buildingLayers[cityKey].addTo(urbanMap);
              console.log(`[Buildings] Added ${cityKey} (${data.features.length} features)`);
            }
          });

          updateBuildingLegend(globalBreaks);

        } else {
          // SINGLE CITY MODE
          const selectedCity = state.selectedCity;

          // Remove all cities first
          Object.keys(cities).forEach((cityKey) => {
            if (buildingLayers[cityKey]) {
              urbanMap.removeLayer(buildingLayers[cityKey]);
              delete buildingLayers[cityKey];
            }
          });

          if (selectedCity) {
            const data = buildingDataCache[selectedCity];

            if (!data || !Array.isArray(data.features) || data.features.length === 0) {
              console.warn(`[Buildings] Selected city "${selectedCity}" has no data.`);
              updateBuildingLegend(null);
              return;
            }

            if (!cityBreaks[selectedCity]) {
              cityBreaks[selectedCity] = calculateCityBreaks(selectedCity);
              console.log(`${selectedCity} breaks:`, cityBreaks[selectedCity]);
            }

            buildingLayers[selectedCity] = createBuildingLayer(selectedCity, cityBreaks[selectedCity]);
            if (buildingLayers[selectedCity]) {
              buildingLayers[selectedCity].addTo(urbanMap);
              console.log(`[Buildings] Added ${selectedCity} with city-specific breaks`);
            }

            updateBuildingLegend(cityBreaks[selectedCity]);
          }
        }

      } else {
        // Hide all buildings when layer is turned off
        Object.keys(cities).forEach((cityKey) => {
          if (buildingLayers[cityKey]) {
            urbanMap.removeLayer(buildingLayers[cityKey]);
            delete buildingLayers[cityKey];
          }
        });
        console.log("All building layers removed");
      }
    }

    function getColorFromBreaksPalette(value, breaks, palette) {
      if (value == null || !breaks?.length) return palette[0];
      for (let i = 0; i < breaks.length; i++) {
        if (value <= breaks[i]) return palette[i] ?? palette[palette.length - 1];
      }
      return palette[palette.length - 1];
    }

    function calculateGlobalCanyonBreaks() {
      const vals = [];
      Object.entries(streetDataCache).forEach(([cityKey, geojson]) => {
        geojson?.features?.forEach(f => {
          const v = getCanyonValue(f);
          if (v != null) vals.push(v);
        });
      });
      return calculateJenksBreaks(vals, 10);
    }

    function calculateCityCanyonBreaks(cityKey) {
      const geojson = streetDataCache[cityKey];
      const vals = (geojson?.features || [])
        .map(f => getCanyonValue(f))
        .filter(v => v != null);
      return calculateJenksBreaks(vals, 10);
    }

    function updateCanyonLegend(breaks) {
      const legendDiv = document.getElementById('canyon-legend');
      if (!legendDiv || !breaks?.length) return;

      const minVal = breaks[0];
      const midVal = breaks[Math.floor(breaks.length / 2)];
      const maxVal = breaks[breaks.length - 1];

      const row = legendDiv.querySelector('.flex.justify-between.text-xs');
      if (row) {
        row.innerHTML = `
          <span>${minVal.toFixed(2)}</span>
          <span>${midVal.toFixed(2)}</span>
          <span>${maxVal.toFixed(2)}+</span>
        `;
      }

      const bar = legendDiv.querySelector('.color-bar-canyon');
      if (bar) {
        bar.style.background = `linear-gradient(to right, ${canyonReds.join(',')})`;
      }
    }



    async function updateStreetLayer() {
      if (!urbanMap) return;

      // remove all if layer off
      if (!state.layers.streets) {
        Object.keys(streetLayers).forEach((cityKey) => {
          urbanMap.removeLayer(streetLayers[cityKey]);
          delete streetLayers[cityKey];
        });
        return;
      }

      await loadAllStreetData();

      // Determine canyon breaks for the current mode (only if canyon toggle ON)
      let canyonBreaksForMode = null;

      if (state.streetOptions.canyon) {
        if (state.viewMode === 'all') {
          if (!globalCanyonBreaks) globalCanyonBreaks = calculateGlobalCanyonBreaks();
          canyonBreaksForMode = globalCanyonBreaks;
        } else {
          const c = state.selectedCity;
          if (c) {
            if (!cityCanyonBreaks[c]) cityCanyonBreaks[c] = calculateCityCanyonBreaks(c);
            canyonBreaksForMode = cityCanyonBreaks[c];
          }
        }
        updateCanyonLegend(canyonBreaksForMode);
      }

      // Clear existing street layers so styles refresh when toggles change
      Object.keys(streetLayers).forEach((cityKey) => {
        urbanMap.removeLayer(streetLayers[cityKey]);
        delete streetLayers[cityKey];
      });

      if (state.viewMode === "all") {
        Object.keys(cities).forEach((cityKey) => {
          const data = streetDataCache[cityKey];
          if (!data?.features?.length) return;

          const layer = createStreetLayer(cityKey, canyonBreaksForMode);
          if (layer) {
            layer.addTo(urbanMap);
            streetLayers[cityKey] = layer;
          }
        });
      } else {
        const cityKey = state.selectedCity;
        if (!cityKey) return;

        const data = streetDataCache[cityKey];
        if (!data?.features?.length) return;

        const layer = createStreetLayer(cityKey, canyonBreaksForMode);
        if (layer) {
          layer.addTo(urbanMap);
          streetLayers[cityKey] = layer;
        }
      }
    }

    async function updateLSTLayer() {
      if (!urbanMap) return;

      // remove old layers
      Object.keys(lstLayers).forEach((cityKey) => {
        urbanMap.removeLayer(lstLayers[cityKey]);
        delete lstLayers[cityKey];
      });

      if (!state.layers.lst) return;

      if (state.viewMode === 'all') {
        if (!globalLSTBreaks) globalLSTBreaks = await calculateGlobalLSTBreaks(); // should be 100
        const palette = makeBlueRamp(globalLSTBreaks.length); // 100 colors
        updateLSTLegend(globalLSTBreaks, palette);

        for (const cityKey of Object.keys(cities)) {
          const georaster = await loadLSTRaster(cityKey);
          if (!georaster) continue;

          const layer = createLSTLayer(cityKey, georaster, globalLSTBreaks, palette);
          if (layer) { layer.addTo(urbanMap); lstLayers[cityKey] = layer; }
        }

      } else {
        const cityKey = state.selectedCity;
        if (!cityKey) return;

        if (!cityLSTBreaks[cityKey]) cityLSTBreaks[cityKey] = await calculateCityLSTBreaks(cityKey); // 100
        const palette = makeBlueRamp(cityLSTBreaks[cityKey].length);
        updateLSTLegend(cityLSTBreaks[cityKey], palette);

        const georaster = await loadLSTRaster(cityKey);
        if (!georaster) return;

        const layer = createLSTLayer(cityKey, georaster, cityLSTBreaks[cityKey], palette);
        if (layer) { layer.addTo(urbanMap); lstLayers[cityKey] = layer; }
      }
    }

async function updatePM25Layer() {
  if (!urbanMap) return;

  // remove old
  Object.keys(pm25Layers).forEach((cityKey) => {
    urbanMap.removeLayer(pm25Layers[cityKey]);
    delete pm25Layers[cityKey];
  });

  if (!state.layers.pm25) return;

  const dateKey = state.pm25?.date || "oct3";
  const timeKey = state.pm25?.time || "08:00";

  // breaks cache buckets
  globalPM25Breaks[dateKey] ??= {};
  cityPM25Breaks[dateKey] ??= {};
  cityPM25Breaks[dateKey][timeKey] ??= {};

  if (state.viewMode === "all") {
    if (!globalPM25Breaks[dateKey][timeKey]) {
      globalPM25Breaks[dateKey][timeKey] = await calculateGlobalPM25Breaks(dateKey, timeKey);
    }

    const breaks = globalPM25Breaks[dateKey][timeKey];
    if (!breaks?.length) return;

    const palette = makeGreenRamp(breaks.length); 
    updatePM25Legend(breaks, palette);

    for (const cityKey of Object.keys(cities)) {
      const georaster = await loadPM25Raster(cityKey, dateKey, timeKey);
      if (!georaster) continue;

      const layer = createPM25Layer(cityKey, georaster, breaks, palette);
      if (layer) {
        layer.addTo(urbanMap);
        pm25Layers[cityKey] = layer;
      }
    }

  } else {
    const cityKey = state.selectedCity;
    if (!cityKey) return;

    if (!cityPM25Breaks[dateKey][timeKey][cityKey]) {
      cityPM25Breaks[dateKey][timeKey][cityKey] = await calculateCityPM25Breaks(cityKey, dateKey, timeKey);
    }

    const breaks = cityPM25Breaks[dateKey][timeKey][cityKey];
    if (!breaks?.length) return;

    const palette = makeGreenRamp(breaks.length);
    updatePM25Legend(breaks, palette);

    const georaster = await loadPM25Raster(cityKey, dateKey, timeKey);
    if (!georaster) return;

    const layer = createPM25Layer(cityKey, georaster, breaks, palette);
    if (layer) {
      layer.addTo(urbanMap);
      pm25Layers[cityKey] = layer;
    }
  }
}
    function updatePM10Layer() { /* TODO */ }

    function setPMDate(element, type, date) {
      state[type].date = date;
      const buttons = element.parentElement.querySelectorAll(`.${type}-date-btn`);
      const activeColor = type === 'pm25' ? 'bg-purple-500' : 'bg-rose-500';

      buttons.forEach(btn => {
        btn.classList.remove(activeColor, 'text-white');
        btn.classList.add('bg-gray-200', 'dark:bg-slate-600');
      });

      element.classList.remove('bg-gray-200', 'dark:bg-slate-600');
      element.classList.add(activeColor, 'text-white');

        if (type === "pm25" && state.layers.pm25) updatePM25Layer();
        if (type === "pm10" && state.layers.pm10) updatePM10Layer();
    }

    function setPMTime(element, type, time) {
      state[type].time = time;
      const buttons = element.parentElement.querySelectorAll(`.${type}-time-btn`);
      const activeColor = type === 'pm25' ? 'bg-purple-500' : 'bg-rose-500';

      buttons.forEach(btn => {
        btn.classList.remove(activeColor, 'text-white');
        btn.classList.add('bg-gray-200', 'dark:bg-slate-600');
      });

      element.classList.remove('bg-gray-200', 'dark:bg-slate-600');
      element.classList.add(activeColor, 'text-white');
      if (type === "pm25" && state.layers.pm25) updatePM25Layer();
      if (type === "pm10" && state.layers.pm10) updatePM10Layer();
    }


    async function loadAllStreetData() {
      const base = new URL('.', window.location.href);

      const loadPromises = Object.keys(cities).map(async (cityKey) => {
        const cached = streetDataCache[cityKey];
        const hasFeatures = cached?.features?.length > 0;
        if (hasFeatures) return;

        const fileKey = cities[cityKey].streetFile || cityKey;
        const url = new URL(`data/street_${fileKey}.geojson`, base).toString();

        try {
          console.log(`[Streets] Fetching ${cityKey}: ${url}`);
          const res = await fetch(url, { cache: "no-store" });
          console.log(`[Streets] ${cityKey} status:`, res.status, res.statusText);
          if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);

          const geojson = await res.json();
          const n = Array.isArray(geojson?.features) ? geojson.features.length : 0;
          console.log(`[Streets] ${cityKey} features:`, n);

          const normalized = (() => {
            if (!geojson || typeof geojson !== "object") {
              return { type: "FeatureCollection", features: [] };
            }
            if (geojson.type === "FeatureCollection" && Array.isArray(geojson.features)) {
              return geojson;
            }
            if (geojson.type === "Feature") {
              return { type: "FeatureCollection", features: [geojson] };
            }
            console.warn(`[Streets] ${cityKey} unexpected GeoJSON type: ${geojson.type}`);
            return { type: "FeatureCollection", features: [] };
          })();

          streetDataCache[cityKey] = normalized;

        } catch (err) {
          console.error(`[Streets] Failed ${cityKey}:`, err);
          streetDataCache[cityKey] = { type: "FeatureCollection", features: [] };
        }
      });

      await Promise.all(loadPromises);
    }



    function getHighwayType(feature) {
      const p = feature?.properties || {};
      // exact attribute name you requested
      return p.highway ?? null;
    }

    function getCanyonValue(feature) {
      const p = feature?.properties || {};
      // exact attribute name you requested
      const num = Number(p.canyon_hw);
      return Number.isFinite(num) ? num : null;
    }

    // Highway palette (matches your legend colors)
    const highwayColors = {
      primary: '#ef4444',
      secondary: '#f97316',
      tertiary: '#eab308',
      residential: '#9ca3af',
      // fallbacks:
      motorway: '#ef4444',
      trunk: '#ef4444',
      unclassified: '#9ca3af',
      service: '#9ca3af'
    };

    // Canyon palette (matches your legend colors)
    const canyonColors = ['#f7fcf5', '#c7e9c0', '#74c476', '#31a354', '#006d2c'];

    function styleStreetFeature(feature, canyonBreaksForMode) {
      // default “old” street network look
      let color = '#06b6d4';
      let weight = 2;
      let opacity = 0.85;

      const highwayOn = !!state.streetOptions.highway;
      const canyonOn  = !!state.streetOptions.canyon;

      // Priority: highway > canyon > default
      if (highwayOn) {
        const typeRaw = getHighwayType(feature);
        const type = (typeRaw ? String(typeRaw).toLowerCase() : 'residential');

        color = highwayColors[type] || highwayColors.residential;
        weight = (type === 'primary' || type === 'motorway' || type === 'trunk') ? 4
              : (type === 'secondary') ? 3
              : 2;

      } else if (canyonOn) {
        const v = getCanyonValue(feature);
        color = getColorFromBreaksPalette(v, canyonBreaksForMode, canyonReds);
        weight = 5; // ✅ requested thicker canyon lines
        opacity = 0.9;
      }

      return { color, weight, opacity };
    }

    function createStreetLayer(cityKey, canyonBreaksForMode) {
      const geojsonData = streetDataCache[cityKey];
      if (!geojsonData?.features?.length) return null;

      if (!urbanMap.getPane('streetsPane')) {
        urbanMap.createPane('streetsPane');
        urbanMap.getPane('streetsPane').style.zIndex = 460;
      }

      try {
        return L.geoJSON(geojsonData, {
          pane: 'streetsPane',
          style: (feature) => styleStreetFeature(feature, canyonBreaksForMode),
          onEachFeature: (feature, layer) => {
            const parts = [];
            const ht = getHighwayType(feature);
            const cv = getCanyonValue(feature);

            if (state.streetOptions.highway && ht != null) parts.push(`Highway: ${ht}`);
            if (state.streetOptions.canyon && cv != null) parts.push(`Canyon HW: ${cv.toFixed(2)}`);

            layer.bindTooltip(parts.length ? parts.join('<br>') : 'Street', { direction: 'top' });
          }
        });
      } catch (e) {
        console.error(`[Streets] Leaflet failed to render ${cityKey}:`, e);
        return null;
      }
    }


    function refreshUrbanMap() {
      if (!urbanMap) return;
      // two passes handles mobile Safari/layout timing
      requestAnimationFrame(() => {
        urbanMap.invalidateSize(true);
        setTimeout(() => urbanMap.invalidateSize(true), 180);
      });
    }

    async function loadLSTRaster(cityKey) {
      if (lstRasterCache[cityKey]) return lstRasterCache[cityKey];

      const fileKey = cities[cityKey]?.lstFile || null;
      if (!fileKey) return null;

      const base = new URL('.', window.location.href);
      const url = new URL(`data/lst_${fileKey}.tif`, base).toString();

      try {
        console.log(`[LST] Fetching ${cityKey}: ${url}`);
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);

        const arrayBuffer = await res.arrayBuffer();
        const georaster = await parseGeoraster(arrayBuffer);

        lstRasterCache[cityKey] = georaster;
        return georaster;
      } catch (e) {
        console.warn(`[LST] Failed to load ${cityKey}:`, e);
        lstRasterCache[cityKey] = null;
        return null;
      }
    }

    // sample values from raster (no normalization) to compute Jenks
    function sampleRasterValues(georaster, maxSamples = 60000) {
      if (!georaster?.values?.length) return [];

      const band = georaster.values[0];
      const h = georaster.height;
      const w = georaster.width;

      const noData = georaster.noDataValue;
      const out = [];

      // stride to keep it fast
      const total = w * h;
      const step = Math.max(1, Math.floor(Math.sqrt(total / maxSamples)));

      for (let y = 0; y < h; y += step) {
        const row = band[y];
        if (!row) continue;
        for (let x = 0; x < w; x += step) {
          const v = row[x];
          if (v == null) continue;
          if (Number.isNaN(v)) continue;
          if (noData != null && v === noData) continue;
          out.push(Number(v));
        }
      }
      return out;
    }

    async function calculateCityLSTBreaks(cityKey) {
      const georaster = await loadLSTRaster(cityKey);
      if (!georaster) return null;

      const vals = sampleRasterValues(georaster, 60000);
      return calculateJenksBreaks(vals, 10); // uses your existing ckmeans helper
    }

    async function calculateGlobalLSTBreaks() {
      const all = [];
      for (const cityKey of Object.keys(cities)) {
        const georaster = await loadLSTRaster(cityKey);
        if (!georaster) continue;
        all.push(...sampleRasterValues(georaster, 25000));
      }
      return calculateJenksBreaks(all, 10);
    }

function updateLSTLegend(breaks, palette) {
  const legendDiv = document.getElementById('lst-legend');
  if (!legendDiv || !breaks?.length) return;

  // mode indicator like building heights
  const modeEl = document.getElementById('lst-mode-indicator');
  if (modeEl) {
    modeEl.textContent =
      state.viewMode === 'all'
        ? 'All Cities'
        : (cities[state.selectedCity]?.name || 'Single');
  }

  // labels
  const minVal = breaks[0];
  const midVal = breaks[Math.floor(breaks.length / 2)];
  const maxVal = breaks[breaks.length - 1];

  const row = legendDiv.querySelector('.flex.justify-between.text-xs');
  if (row) {
    row.innerHTML = `
      <span>${minVal.toFixed(2)}</span>
      <span>${midVal.toFixed(2)}</span>
      <span>${maxVal.toFixed(2)}+</span>
    `;
  }

  // gradient bar
  const bar = document.getElementById('lst-colorbar');
  setLegendGradient(bar, palette);
}

function createLSTLayer(cityKey, georaster, breaks, palette) {
  if (!urbanMap || !georaster || !breaks?.length) return null;

  if (!urbanMap.getPane('lstPane')) {
    urbanMap.createPane('lstPane');
    urbanMap.getPane('lstPane').style.zIndex = 420;
  }

  const noData = georaster.noDataValue;

  return new GeoRasterLayer({
    georaster,
    pane: 'lstPane',
    opacity: 1,
    resolution: 256,
    pixelValuesToColorFn: (vals) => {
      const v = vals?.[0];
      if (v == null || Number.isNaN(v)) return null;
      if (noData != null && v === noData) return null;
      return getColorFromBreaksPalette(Number(v), breaks, palette);
    }
  });
}

    // =====================
    // Basemap Control (Urban + Sensors)
    // =====================
    function setBasemap(type) {
      state.basemap = type;

      function updateButtons(lightId, osmId) {
        const lightBtn = document.getElementById(lightId);
        const osmBtn = document.getElementById(osmId);
        if (!lightBtn || !osmBtn) return;

        [lightBtn, osmBtn].forEach(btn => {
          btn.classList.remove('border-emerald-500');
          btn.classList.add('border-transparent');
        });

        if (type === 'light') {
          lightBtn.classList.add('border-emerald-500');
          lightBtn.classList.remove('border-transparent');
        } else if (type === 'osm') {
          osmBtn.classList.add('border-emerald-500');
          osmBtn.classList.remove('border-transparent');
        }
      }

      updateButtons('basemap-light', 'basemap-osm');
      updateButtons('basemap-light-sensor', 'basemap-osm-sensor');

      if (basemapLayers.urban) basemapLayers.urban.setUrl(basemaps[type]);
      if (basemapLayers.sensor) basemapLayers.sensor.setUrl(basemaps[type]);
    }

    // =====================
    // Sensor Controls
    // =====================
    function toggleSensorLayer(type) {
      state.sensorLayers[type] = !state.sensorLayers[type];

      if (type === "airgradient") {
        Object.entries(sensorMarkers).forEach(([key, marker]) => {
          if (state.sensorLayers.airgradient) marker.addTo(sensorMap);
          else sensorMap.removeLayer(marker);
        });
      }

      updateSensorLocationsList();
    }

    function calculateGlobalBuildingCentroid() {
      const globalBounds = L.latLngBounds([]);

      Object.keys(cities).forEach(cityKey => {
        const geojsonData = buildingDataCache[cityKey];
        if (!geojsonData?.features?.length) return;

        for (const f of geojsonData.features) {
          const g = f?.geometry;
          if (!g) continue;

          if (g.type === "Polygon") {
            const ring = g.coordinates?.[0] || [];
            for (const [lng, lat] of ring) {
              if (Number.isFinite(lat) && Number.isFinite(lng) && Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                globalBounds.extend([lat, lng]);
              }
            }
          } else if (g.type === "MultiPolygon") {
            for (const poly of g.coordinates || []) {
              const ring = poly?.[0] || [];
              for (const [lng, lat] of ring) {
                if (Number.isFinite(lat) && Number.isFinite(lng) && Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
                  globalBounds.extend([lat, lng]);
                }
              }
            }
          }
        }
      });

      if (!globalBounds.isValid()) return [14.5995, 121.0037]; // fallback
      const c = globalBounds.getCenter();
      return [c.lat, c.lng];
    }

function updateSensorLocationsList() {
  const locationsContainer = document.getElementById('sensor-locations');
  const listContainer = document.getElementById('sensor-list');

  // only show if airgradient layer is enabled
  const anySensorActive = !!state.sensorLayers.airgradient;
  if (!anySensorActive) {
    locationsContainer.classList.add('hidden');
    return;
  }

  locationsContainer.classList.remove('hidden');
  listContainer.innerHTML = '';

  Object.entries(sensorStations).forEach(([key, st]) => {
    const color = '#10b981';

    const locationItem = document.createElement('div');
    locationItem.className =
      'p-3 rounded-lg bg-gray-50 dark:bg-slate-700/50 hover:bg-gray-100 dark:hover:bg-slate-700 cursor-pointer transition-colors';

    locationItem.innerHTML = `
      <div class="flex items-center gap-2 mb-1">
        <div class="w-3 h-3 rounded-full" style="background-color: ${color}"></div>
        <span class="text-sm font-medium">${st.name}</span>
      </div>
      <div class="text-xs text-gray-500 dark:text-gray-400 ml-5">
        ${st.coords[0].toFixed(4)}°, ${st.coords[1].toFixed(4)}°
      </div>
    `;

    locationItem.onclick = () => focusSensor(key);
    listContainer.appendChild(locationItem);
  });
}

function focusSensor(stationKey) {
  const st = sensorStations[stationKey];
  if (!st) return;
  sensorMap.flyTo(st.coords, 16, { duration: 1 });
  showSensorDetail(stationKey);
}

async function showSensorDetail(stationKey) {
  const st = sensorStations[stationKey];
  if (!st) return;

  document.getElementById("sensor-name").textContent = st.name;
  document.getElementById("detail-location").textContent =
    `${st.coords[0].toFixed(4)}, ${st.coords[1].toFixed(4)}`;

  const ts = await loadStationTimeSeries(stationKey);

  // Reset date inputs to last 24 hours
  const fromEl = document.getElementById("ts-from");
  const toEl = document.getElementById("ts-to");

  if (ts?.maxDate && fromEl && toEl) {
    const toD = new Date(ts.maxDate.getTime());
    const fromD = new Date(ts.maxDate.getTime() - 24 * 3600 * 1000);

    if (fromEl && !fromEl.value) fromEl.value = toDateTimeLocalValue(defaultFrom);
    if (toEl && !toEl.value)     toEl.value   = toDateTimeLocalValue(defaultTo);
  }

  const { from, to } = readRangeInputsOrDefault(ts);
  const metric = document.getElementById("ts-metric").value || "pm25";

  const filtered = filterRowsByRange(ts.rows, from, to);

  // show panel FIRST
  const panel = document.getElementById("sensor-detail");
  panel.classList.remove("hidden");

  requestAnimationFrame(() => {
    renderTimeSeriesChart(filtered, metric);
  });

  // Apply button
  document.getElementById("ts-apply").onclick = () => {
    const { from, to } = readRangeInputsOrDefault(ts);
    const metric = document.getElementById("ts-metric").value;
    const filtered = filterRowsByRange(ts.rows, from, to);
    renderTimeSeriesChart(filtered, metric);
  };
}

    function closeSensorDetail() {
      document.getElementById('sensor-detail').classList.add('hidden');
    }

    // =====================
    // UI Controls
    // =====================
    function toggleDarkMode() {
      state.darkMode = !state.darkMode;
      document.documentElement.classList.toggle('dark', state.darkMode);

      document.documentElement.style.setProperty('--control-bg', state.darkMode ? '#1e293b' : '#ffffff');
      document.documentElement.style.setProperty('--control-text', state.darkMode ? '#e2e8f0' : '#1f2937');
      document.documentElement.style.setProperty('--control-border', state.darkMode ? '#334155' : '#e5e7eb');
    }


    function toggleLeftPanel() {
      const panel = document.getElementById('left-panel');
      const isHidden = panel.classList.contains('mobile-hidden');
      if (isHidden) openMobilePanel();
      else closeMobilePanel();
    }

    // =====================
    // Initialize
    // =====================
    document.addEventListener('DOMContentLoaded', async () => {
      await initMaps();
      setBasemap(state.basemap);
      showLanding();
      syncMobileHomeVisibility();

      const b = document.getElementById('layer-buildings');
      if (b) b.checked = true;
      document.getElementById('building-legend')?.classList.remove('hidden');

      // Set UI state only — don't render buildings yet (map is hidden behind landing)
      await setViewMode('all', false);
      handleResponsivePanels();
      syncFloatingButtonsVisibility(); // run again after responsive logic
    });



function syncFloatingButtonsVisibility() {
  const landing = document.getElementById('landing');
  const landingVisible = landing && !landing.classList.contains('hidden');

  const isMobile = window.innerWidth < 768;

  // Floating buttons
  const mobileHome = document.getElementById('mobile-home');

  const urbanToggle = document.getElementById('urban-panel-toggle-btn');
  const urbanOpen   = document.getElementById('urban-open-panel-btn');

  const sensorToggle = document.getElementById('sensor-panel-toggle-btn');
  const sensorOpen   = document.getElementById('sensor-open-panel-btn');

  // If Landing is visible OR not mobile -> hide all floating controls
  if (!isMobile || landingVisible) {
    mobileHome?.classList.add('hidden');
    urbanToggle?.classList.add('hidden');
    urbanOpen?.classList.add('hidden');
    sensorToggle?.classList.add('hidden');
    sensorOpen?.classList.add('hidden');
    return;
  }

  // Landing is hidden AND mobile:
  // Show mobile home button
  mobileHome?.classList.remove('hidden');

  // Show floating panel buttons only for the active tab, and only depending on panel state
  if (state.currentTab === 'urban') {
    const urbanPanelHidden = document.getElementById('left-panel')?.classList.contains('mobile-hidden');
    if (urbanPanelHidden) {
      urbanToggle?.classList.add('hidden');
      urbanOpen?.classList.remove('hidden');
    } else {
      urbanOpen?.classList.add('hidden');
      urbanToggle?.classList.remove('hidden');
    }

    // hide sensor floats
    sensorToggle?.classList.add('hidden');
    sensorOpen?.classList.add('hidden');
  } else {
    const sensorPanelHidden = document.getElementById('sensor-left-panel')?.classList.contains('mobile-hidden-sensor');
    if (sensorPanelHidden) {
      sensorToggle?.classList.add('hidden');
      sensorOpen?.classList.remove('hidden');
    } else {
      sensorOpen?.classList.add('hidden');
      sensorToggle?.classList.remove('hidden');
    }

    // hide urban floats
    urbanToggle?.classList.add('hidden');
    urbanOpen?.classList.add('hidden');
  }
}

function pm25Folder(dateKey) {
  // dateKey values you already use: "oct3" / "oct4"
  return dateKey === "oct3" ? "PM25_1003" : "PM25_1004";
}

function pm25DateStamp(dateKey) {
  return dateKey === "oct3" ? "20251003" : "20251004";
}

// state.pm25.time is "08:00" etc → filenames use "0800"
function pm25TimeStamp(timeKey) {
  return String(timeKey).replace(":", "");
}

async function loadPM25Raster(cityKey, dateKey, timeKey) {
  pm25RasterCache[dateKey] ??= {};
  pm25RasterCache[dateKey][cityKey] ??= {};
  if (pm25RasterCache[dateKey][cityKey][timeKey]) return pm25RasterCache[dateKey][cityKey][timeKey];

  const code = PM25_CITY_CODE[cityKey];
  if (!code) return null;

  const folder = pm25Folder(dateKey);
  const dateStamp = pm25DateStamp(dateKey);
  const timeStamp = pm25TimeStamp(timeKey);

  // Example: data/PM25_1003/PM25_PL_20251003_0800.tif
  const base = new URL(".", window.location.href);
  const url = new URL(`data/${folder}/PM25_${code}_${dateStamp}_${timeStamp}.tif`, base).toString();

  try {
    console.log(`[PM25] Fetching ${cityKey} ${dateKey} ${timeKey}: ${url}`);
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);

    const arrayBuffer = await res.arrayBuffer();
    const georaster = await parseGeoraster(arrayBuffer);

    pm25RasterCache[dateKey][cityKey][timeKey] = georaster;
    return georaster;
  } catch (e) {
    console.warn(`[PM25] Failed to load ${cityKey} ${dateKey} ${timeKey}:`, e);
    pm25RasterCache[dateKey][cityKey][timeKey] = null;
    return null;
  }
}

async function calculateCityPM25Breaks(cityKey, dateKey, timeKey) {
  const georaster = await loadPM25Raster(cityKey, dateKey, timeKey);
  if (!georaster) return null;

  const vals = sampleRasterValues(georaster, 60000);
  return calculateJenksBreaks(vals, 100);
}

async function calculateGlobalPM25Breaks(dateKey, timeKey) {
  const all = [];
  for (const cityKey of Object.keys(cities)) {
    const georaster = await loadPM25Raster(cityKey, dateKey, timeKey);
    if (!georaster) continue;
    all.push(...sampleRasterValues(georaster, 25000));
  }
  return calculateJenksBreaks(all, 100);
}

function updatePM25Legend(breaks, palette) {
  const wrap = document.getElementById("pm25-options");
  if (!wrap || !breaks?.length) return;

  // Find the gradient bar inside PM2.5 panel
  const bar = wrap.querySelector(".color-bar-pm25");

  // Find the min/mid/max label row
  const row = wrap.querySelector(".flex.justify-between.text-xs");

  const minVal = breaks[0];
  const midVal = breaks[Math.floor(breaks.length / 2)];
  const maxVal = breaks[breaks.length - 1];

  // Update numeric labels
  if (row) {
    row.innerHTML = `
      <span>${minVal.toFixed(1)}</span>
      <span>${midVal.toFixed(1)}</span>
      <span>${maxVal.toFixed(1)}+</span>
    `;
  }

  // ✅ THIS is where it goes
  if (bar) {
    setLegendGradient(bar, palette);
  }
}

function createPM25Layer(cityKey, georaster, breaks, palette) {
  if (!urbanMap || !georaster || !breaks?.length) return null;

  if (!urbanMap.getPane("pm25Pane")) {
    urbanMap.createPane("pm25Pane");
    urbanMap.getPane("pm25Pane").style.zIndex = 410; // under LST (420) and buildings/streets
  }

  const noData = georaster.noDataValue;

  return new GeoRasterLayer({
    georaster,
    pane: "pm25Pane",
    opacity: 1,
    resolution: 256,
    pixelValuesToColorFn: (vals) => {
      const v = vals?.[0];
      if (v == null || Number.isNaN(v)) return null;
      if (noData != null && v === noData) return null;
      return getColorFromBreaksPalette(Number(v), breaks, palette);
    }
  });
}



// =====================
// One Time-Series Chart (CSV-backed)
// =====================
let tsChart = null;
const timeSeriesCache = {}; // { stationKey: { rows: [...], minDate, maxDate } }

// Use lowercase keys here
const TS_COLS = {
  utc: ["utc_date_time", "timestamp", "date_time", "datetime"],
  pm25: ["pm25_ug_m3_corrected", "pm25_ug_m3"],
  pm10: ["pm10_ug_m3_corrected", "pm10_ug_m3"],
  humidity: ["humidity_percent_corrected", "humidity_percent", "rh_percent"],
  temperature: ["temperature_c_corrected", "temperature_c", "temp_c"],
};

function normHeader(h) {
  return String(h || "")
    .replace(/^\uFEFF/, "")   // remove BOM if present
    .trim()
    .toLowerCase();
}

function toDateTimeLocalUTCValue(d) {
  const pad = n => String(n).padStart(2, "0");
  return `${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}T${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}`;
}

// Parse datetime-local as UTC (not local)
function parseDateTimeLocalAsLocal(value) {
  // value like "2026-01-04T14:50" -> local Date
  return value ? new Date(value) : null;
}

function parseCSVLine(line) {
  const out = [];
  let cur = "", inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (ch === '"') {
      if (inQuotes && line[i + 1] === '"') { cur += '"'; i++; }
      else inQuotes = !inQuotes;
    } else if (ch === "," && !inQuotes) {
      out.push(cur); cur = "";
    } else cur += ch;
  }
  out.push(cur);
  return out.map(s => s.trim().replace(/^\uFEFF/, ""));
}

function parseLocalDateTime(s) {
  if (!s) return null;

  // normalize "YYYY-MM-DD HH:mm:ss" -> "YYYY-MM-DDTHH:mm:ss"
  const isoLike = s.includes("T") ? s : s.replace(" ", "T");

  // IMPORTANT: do NOT append Z (Z makes it UTC)
  const d = new Date(isoLike);
  return Number.isNaN(d.getTime()) ? null : d;
}

async function loadStationTimeSeries(stationKey) {
  if (timeSeriesCache[stationKey]) return timeSeriesCache[stationKey];

  const st = sensorStations[stationKey];
  if (!st?.file) return { rows: [], minDate: null, maxDate: null };

  const base = new URL(".", window.location.href);
  const url = new URL(`data/timeseries/${st.file}`, base).toString();

  try {
    const res = await fetch(url, { cache: "no-store" });
    console.log("[Timeseries] fetching:", url, "status:", res.status);
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);

    const text = await res.text();
    const lines = text.split(/\r?\n/).filter(l => l.trim().length);
    if (!lines.length) throw new Error("Empty CSV");

    const header = parseCSVLine(lines[0]);
    const idx = Object.fromEntries(header.map((h, i) => [h.trim(), i]));

    console.log("[Timeseries] headers:", header);

    // --- EXACT column names from your CSV ---
    const localIdx = idx["local_date_time"];
    const pm25Idx  = idx["pm25_ug_m3_corrected"];
    const pm10Idx  = idx["pm10_ug_m3"];
    const humIdx   = idx["humidity_percent_corrected"];
    const tempIdx  = idx["temperature_c_corrected"];

    console.log("[Timeseries] column indices:", {
      localIdx, pm25Idx, pm10Idx, humIdx, tempIdx
    });

    if (localIdx == null) {
      throw new Error("local_date_time column not found.");
    }

    const toNum = (cols, j) => {
      if (j == null) return null;
      const v = Number(cols[j]);
      return Number.isFinite(v) ? v : null;
    };

    const rows = [];

    for (let i = 1; i < lines.length; i++) {
      const cols = parseCSVLine(lines[i]);
      if (!cols?.length) continue;

      // Convert "2026-01-04 22:50:00" → Date
      const localStr = cols[localIdx];
      const t = new Date(localStr.replace(" ", "T")); // no Z, local time
      if (isNaN(t.getTime())) continue;

      rows.push({
        t,
        pm25: toNum(cols, pm25Idx),
        pm10: toNum(cols, pm10Idx),
        humidity: toNum(cols, humIdx),
        temperature: toNum(cols, tempIdx),
      });
    }

    rows.sort((a, b) => a.t - b.t);

    const minDate = rows[0]?.t ?? null;
    const maxDate = rows[rows.length - 1]?.t ?? null;

    console.log("[Timeseries] rows:", rows.length, "min:", minDate, "max:", maxDate);

    timeSeriesCache[stationKey] = { rows, minDate, maxDate };
    return timeSeriesCache[stationKey];

  } catch (e) {
    console.warn("[Timeseries] load failed:", stationKey, e);
    timeSeriesCache[stationKey] = { rows: [], minDate: null, maxDate: null };
    return timeSeriesCache[stationKey];
  }
}

function toDateTimeLocalValue(d) {
  const pad = n => String(n).padStart(2, "0");
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
}

function readRangeInputsOrDefault(ts) {
  const fromEl = document.getElementById("ts-from");
  const toEl   = document.getElementById("ts-to");

  const maxD = ts?.maxDate ?? new Date();
  const defaultTo = new Date(maxD.getTime());
  const defaultFrom = new Date(maxD.getTime() - 24 * 3600 * 1000);

  if (fromEl && !fromEl.value)
    fromEl.value = defaultFrom.toISOString().slice(0,16);

  if (toEl && !toEl.value)
    toEl.value = defaultTo.toISOString().slice(0,16);

  const from = fromEl?.value ? new Date(fromEl.value) : defaultFrom;
  const to   = toEl?.value   ? new Date(toEl.value)   : defaultTo;

  return { from, to };
}

function filterRowsByRange(rows, from, to) {
  const a = from.getTime();
  const b = to.getTime();
  return rows.filter(r => {
    const t = r.t.getTime();
    return t >= a && t <= b;
  });
}

function metricLabel(metricKey) {
  switch (metricKey) {
    case "pm25": return "PM2.5 (µg/m³)";
    case "pm10": return "PM10 (µg/m³)";
    case "humidity": return "Humidity (%)";
    case "temperature": return "Temperature (°C)";
    default: return metricKey;
  }
}

function renderTimeSeriesChart(filtered, metricKey) {
  const canvas = document.getElementById("ts-chart");
  if (!canvas) return;

  const points = filtered
    .filter(r => r[metricKey] != null)
    .map(r => ({ x: r.t, y: r[metricKey] }));

  console.log("[Chart] metric:", metricKey, "points:", points.length);

  if (tsChart) {
    tsChart.destroy();
    tsChart = null;
  }

  tsChart = new Chart(canvas, {
    type: "line",
    data: {
      datasets: [{
        label: metricKey,
        data: points,
        borderWidth: 2,
        pointRadius: 0,
        tension: 0.3
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      parsing: false,
      scales: {
        x: {
          type: "time",
          time: { tooltipFormat: "yyyy-LL-dd HH:mm" }
        }
      }
    }
  });
}

  </script>

  <!-- Cloudflare challenge script (kept as-is) -->
  <script>
    (function(){
      function c(){
        var b=a.contentDocument||a.contentWindow.document;
        if(b){
          var d=b.createElement('script');
          d.innerHTML="window.__CF$cv$params={r:'9d276f1512fcfecc',t:'MTc3MTg1NzE2MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";
          b.getElementsByTagName('head')[0].appendChild(d)
        }
      }
      if(document.body){
        var a=document.createElement('iframe');
        a.height=1;a.width=1;
        a.style.position='absolute';
        a.style.top=0;a.style.left=0;
        a.style.border='none';
        a.style.visibility='hidden';
        document.body.appendChild(a);
        if('loading'!==document.readyState)c();
        else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);
        else{
          var e=document.onreadystatechange||function(){};
          document.onreadystatechange=function(b){
            e(b);
            'loading'!==document.readyState&&(document.onreadystatechange=e,c())
          }
        }
      }
    })();


function syncMobileHomeVisibility() {
  const landing = document.getElementById('landing');
  const about = document.getElementById('about');

  const landingVisible = landing && !landing.classList.contains('hidden');
  const aboutVisible   = about && !about.classList.contains('hidden');
  const overlayVisible = landingVisible || aboutVisible;

  // Home button: show only when NOT on overlays
  const homeBtn = document.getElementById('mobile-home');
  if (homeBtn) homeBtn.classList.toggle('hidden', overlayVisible);

  // Hide lower-left floating panel buttons while overlays are visible
  const ids = [
    'urban-panel-toggle-btn',
    'urban-open-panel-btn',
    'sensor-panel-toggle-btn',
    'sensor-open-panel-btn'
  ];
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.toggle('hidden', overlayVisible);
  });
}

  </script>

<!-- Mobile floating Home button -->
<button
  id="mobile-home"
  onclick="showLanding()"
  class="md:hidden fixed bottom-5 right-5 z-50 w-12 h-12 rounded-full bg-emerald-500 text-white shadow-lg flex items-center justify-center active:scale-95 transition"
  aria-label="Home"
  title="Home"
>
  <!-- simple home icon -->
  <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
      d="M3 10.5L12 3l9 7.5V20a1 1 0 01-1 1h-5v-6H9v6H4a1 1 0 01-1-1v-9.5z"/>
  </svg>
</button>


</body>
</html>
